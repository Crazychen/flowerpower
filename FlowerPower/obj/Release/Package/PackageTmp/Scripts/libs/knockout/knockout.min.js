/* 2.1.0 VERSION*/
(function (window, document, navigator, undefined) {
    var DEBUG = true; !function (factory) { if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') { var target = module['exports'] || exports; factory(target); } else if (typeof define === 'function' && define['amd']) { define(['exports'], factory); } else { factory(window['ko'] = {}); } }(function (koExports) {
        var ko = typeof koExports !== 'undefined' ? koExports : {}; ko.exportSymbol = function (koPath, object) {
            var tokens = koPath.split("."); var target = ko; for (var i = 0; i < tokens.length - 1; i++)
                target = target[tokens[i]]; target[tokens[tokens.length - 1]] = object;
        }; ko.exportProperty = function (owner, publicName, object) { owner[publicName] = object; }; ko.version = "2.1.0"; ko.exportSymbol('version', ko.version); ko.utils = new (function () {
            var stringTrimRegex = /^(\s|\u00A0)+|(\s|\u00A0)+$/g; var knownEvents = {}, knownEventTypesByEventName = {}; var keyEventTypeName = /Firefox\/2/i.test(navigator.userAgent) ? 'KeyboardEvent' : 'UIEvents'; knownEvents[keyEventTypeName] = ['keyup', 'keydown', 'keypress']; knownEvents['MouseEvents'] = ['click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave']; for (var eventType in knownEvents) {
                var knownEventsForType = knownEvents[eventType]; if (knownEventsForType.length) {
                    for (var i = 0, j = knownEventsForType.length; i < j; i++)
                        knownEventTypesByEventName[knownEventsForType[i]] = eventType;
                }
            }
            var eventsThatMustBeRegisteredUsingAttachEvent = { 'propertychange': true }; var ieVersion = (function () { var version = 3, div = document.createElement('div'), iElems = div.getElementsByTagName('i'); while (div.innerHTML = '<!--[if gt IE ' + (++version) + ']><i></i><![endif]-->', iElems[0]); return version > 4 ? version : undefined; }()); var isIe6 = ieVersion === 6, isIe7 = ieVersion === 7; function isClickOnCheckableElement(element, eventType) { if ((ko.utils.tagNameLower(element) !== "input") || !element.type) return false; if (eventType.toLowerCase() != "click") return false; var inputType = element.type; return (inputType == "checkbox") || (inputType == "radio"); }
            return {
                fieldsIncludedWithJsonPost: ['authenticity_token', /^__RequestVerificationToken(_.*)?$/], arrayForEach: function (array, action) {
                    for (var i = 0, j = array.length; i < j; i++)
                        action(array[i]);
                }, arrayIndexOf: function (array, item) {
                    if (typeof Array.prototype.indexOf == "function")
                        return Array.prototype.indexOf.call(array, item); for (var i = 0, j = array.length; i < j; i++)
                            if (array[i] === item)
                                return i; return -1;
                }, arrayFirst: function (array, predicate, predicateOwner) {
                    for (var i = 0, j = array.length; i < j; i++)
                        if (predicate.call(predicateOwner, array[i]))
                            return array[i]; return null;
                }, arrayRemoveItem: function (array, itemToRemove) {
                    var index = ko.utils.arrayIndexOf(array, itemToRemove); if (index >= 0)
                        array.splice(index, 1);
                }, arrayGetDistinctValues: function (array) {
                    array = array || []; var result = []; for (var i = 0, j = array.length; i < j; i++) {
                        if (ko.utils.arrayIndexOf(result, array[i]) < 0)
                            result.push(array[i]);
                    }
                    return result;
                }, arrayMap: function (array, mapping) {
                    array = array || []; var result = []; for (var i = 0, j = array.length; i < j; i++)
                        result.push(mapping(array[i])); return result;
                }, arrayFilter: function (array, predicate) {
                    array = array || []; var result = []; for (var i = 0, j = array.length; i < j; i++)
                        if (predicate(array[i]))
                            result.push(array[i]); return result;
                }, arrayPushAll: function (array, valuesToPush) {
                    if (valuesToPush instanceof Array)
                        array.push.apply(array, valuesToPush); else
                        for (var i = 0, j = valuesToPush.length; i < j; i++)
                            array.push(valuesToPush[i]); return array;
                }, extend: function (target, source) {
                    if (source) { for (var prop in source) { if (source.hasOwnProperty(prop)) { target[prop] = source[prop]; } } }
                    return target;
                }, emptyDomNode: function (domNode) { while (domNode.firstChild) { ko.removeNode(domNode.firstChild); } }, moveCleanedNodesToContainerElement: function (nodes) {
                    var nodesArray = ko.utils.makeArray(nodes); var container = document.createElement('div'); for (var i = 0, j = nodesArray.length; i < j; i++) { ko.cleanNode(nodesArray[i]); container.appendChild(nodesArray[i]); }
                    return container;
                }, setDomNodeChildren: function (domNode, childNodes) {
                    ko.utils.emptyDomNode(domNode); if (childNodes) {
                        for (var i = 0, j = childNodes.length; i < j; i++)
                            domNode.appendChild(childNodes[i]);
                    }
                }, replaceDomNodes: function (nodeToReplaceOrNodeArray, newNodesArray) {
                    var nodesToReplaceArray = nodeToReplaceOrNodeArray.nodeType ? [nodeToReplaceOrNodeArray] : nodeToReplaceOrNodeArray; if (nodesToReplaceArray.length > 0) {
                        var insertionPoint = nodesToReplaceArray[0]; var parent = insertionPoint.parentNode; for (var i = 0, j = newNodesArray.length; i < j; i++)
                            parent.insertBefore(newNodesArray[i], insertionPoint); for (var i = 0, j = nodesToReplaceArray.length; i < j; i++) { ko.removeNode(nodesToReplaceArray[i]); }
                    }
                }, setOptionNodeSelectionState: function (optionNode, isSelected) {
                    if (navigator.userAgent.indexOf("MSIE 6") >= 0)
                        optionNode.setAttribute("selected", isSelected); else
                        optionNode.selected = isSelected;
                }, stringTrim: function (string) { return (string || "").replace(stringTrimRegex, ""); }, stringTokenize: function (string, delimiter) {
                    var result = []; var tokens = (string || "").split(delimiter); for (var i = 0, j = tokens.length; i < j; i++) {
                        var trimmed = ko.utils.stringTrim(tokens[i]); if (trimmed !== "")
                            result.push(trimmed);
                    }
                    return result;
                }, stringStartsWith: function (string, startsWith) {
                    string = string || ""; if (startsWith.length > string.length)
                        return false; return string.substring(0, startsWith.length) === startsWith;
                }, buildEvalWithinScopeFunction: function (expression, scopeLevels) {
                    var functionBody = "return (" + expression + ")"; for (var i = 0; i < scopeLevels; i++) { functionBody = "with(sc[" + i + "]) { " + functionBody + " } "; }
                    return new Function("sc", functionBody);
                }, domNodeIsContainedBy: function (node, containedByNode) {
                    if (containedByNode.compareDocumentPosition)
                        return (containedByNode.compareDocumentPosition(node) & 16) == 16; while (node != null) {
                            if (node == containedByNode)
                                return true; node = node.parentNode;
                        }
                    return false;
                }, domNodeIsAttachedToDocument: function (node) { return ko.utils.domNodeIsContainedBy(node, node.ownerDocument); }, tagNameLower: function (element) { return element && element.tagName && element.tagName.toLowerCase(); }, registerEventHandler: function (element, eventType, handler) {
                    var mustUseAttachEvent = ieVersion && eventsThatMustBeRegisteredUsingAttachEvent[eventType]; if (!mustUseAttachEvent && typeof jQuery != "undefined") {
                        if (isClickOnCheckableElement(element, eventType)) {
                            var originalHandler = handler; handler = function (event, eventData) {
                                var jQuerySuppliedCheckedState = this.checked; if (eventData)
                                    this.checked = eventData.checkedStateBeforeEvent !== true; originalHandler.call(this, event); this.checked = jQuerySuppliedCheckedState;
                            };
                        }
                        jQuery(element)['bind'](eventType, handler);
                    } else if (!mustUseAttachEvent && typeof element.addEventListener == "function")
                        element.addEventListener(eventType, handler, false); else if (typeof element.attachEvent != "undefined")
                            element.attachEvent("on" + eventType, function (event) { handler.call(element, event); }); else
                            throw new Error("Browser doesn't support addEventListener or attachEvent");
                }, triggerEvent: function (element, eventType) {
                    if (!(element && element.nodeType))
                        throw new Error("element must be a DOM node when calling triggerEvent"); if (typeof jQuery != "undefined") {
                            var eventData = []; if (isClickOnCheckableElement(element, eventType)) { eventData.push({ checkedStateBeforeEvent: element.checked }); }
                            jQuery(element)['trigger'](eventType, eventData);
                        } else if (typeof document.createEvent == "function") {
                            if (typeof element.dispatchEvent == "function") { var eventCategory = knownEventTypesByEventName[eventType] || "HTMLEvents"; var event = document.createEvent(eventCategory); event.initEvent(eventType, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, element); element.dispatchEvent(event); }
                            else
                                throw new Error("The supplied element doesn't support dispatchEvent");
                        } else if (typeof element.fireEvent != "undefined") {
                            if (isClickOnCheckableElement(element, eventType))
                                element.checked = element.checked !== true; element.fireEvent("on" + eventType);
                        }
                        else
                            throw new Error("Browser doesn't support triggering events");
                }, unwrapObservable: function (value) { return ko.isObservable(value) ? value() : value; }, toggleDomNodeCssClass: function (node, className, shouldHaveClass) {
                    var currentClassNames = (node.className || "").split(/\s+/); var hasClass = ko.utils.arrayIndexOf(currentClassNames, className) >= 0; if (shouldHaveClass && !hasClass) { node.className += (currentClassNames[0] ? " " : "") + className; } else if (hasClass && !shouldHaveClass) {
                        var newClassName = ""; for (var i = 0; i < currentClassNames.length; i++)
                            if (currentClassNames[i] != className)
                                newClassName += currentClassNames[i] + " "; node.className = ko.utils.stringTrim(newClassName);
                    }
                }, setTextContent: function (element, textContent) {
                    var value = ko.utils.unwrapObservable(textContent); if ((value === null) || (value === undefined))
                        value = ""; 'innerText' in element ? element.innerText = value : element.textContent = value; if (ieVersion >= 9) { element.style.display = element.style.display; }
                }, ensureSelectElementIsRenderedCorrectly: function (selectElement) { if (ieVersion >= 9) { var originalWidth = selectElement.style.width; selectElement.style.width = 0; selectElement.style.width = originalWidth; } }, range: function (min, max) {
                    min = ko.utils.unwrapObservable(min); max = ko.utils.unwrapObservable(max); var result = []; for (var i = min; i <= max; i++)
                        result.push(i); return result;
                }, makeArray: function (arrayLikeObject) { var result = []; for (var i = 0, j = arrayLikeObject.length; i < j; i++) { result.push(arrayLikeObject[i]); }; return result; }, isIe6: isIe6, isIe7: isIe7, ieVersion: ieVersion, getFormFields: function (form, fieldName) {
                    var fields = ko.utils.makeArray(form.getElementsByTagName("input")).concat(ko.utils.makeArray(form.getElementsByTagName("textarea"))); var isMatchingField = (typeof fieldName == 'string') ? function (field) { return field.name === fieldName } : function (field) { return fieldName.test(field.name) }; var matches = []; for (var i = fields.length - 1; i >= 0; i--) {
                        if (isMatchingField(fields[i]))
                            matches.push(fields[i]);
                    }; return matches;
                }, parseJson: function (jsonString) {
                    if (typeof jsonString == "string") {
                        jsonString = ko.utils.stringTrim(jsonString); if (jsonString) {
                            if (window.JSON && window.JSON.parse)
                                return window.JSON.parse(jsonString); return (new Function("return " + jsonString))();
                        }
                    }
                    return null;
                }, stringifyJson: function (data, replacer, space) {
                    if ((typeof JSON == "undefined") || (typeof JSON.stringify == "undefined"))
                        throw new Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js"); return JSON.stringify(ko.utils.unwrapObservable(data), replacer, space);
                }, postJson: function (urlOrForm, data, options) {
                    options = options || {}; var params = options['params'] || {}; var includeFields = options['includeFields'] || this.fieldsIncludedWithJsonPost; var url = urlOrForm; if ((typeof urlOrForm == 'object') && (ko.utils.tagNameLower(urlOrForm) === "form")) {
                        var originalForm = urlOrForm; url = originalForm.action; for (var i = includeFields.length - 1; i >= 0; i--) {
                            var fields = ko.utils.getFormFields(originalForm, includeFields[i]); for (var j = fields.length - 1; j >= 0; j--)
                                params[fields[j].name] = fields[j].value;
                        }
                    }
                    data = ko.utils.unwrapObservable(data); var form = document.createElement("form"); form.style.display = "none"; form.action = url; form.method = "post"; for (var key in data) { var input = document.createElement("input"); input.name = key; input.value = ko.utils.stringifyJson(ko.utils.unwrapObservable(data[key])); form.appendChild(input); }
                    for (var key in params) { var input = document.createElement("input"); input.name = key; input.value = params[key]; form.appendChild(input); }
                    document.body.appendChild(form); options['submitter'] ? options['submitter'](form) : form.submit(); setTimeout(function () { form.parentNode.removeChild(form); }, 0);
                }
            }
        })(); ko.exportSymbol('utils', ko.utils); ko.exportSymbol('utils.arrayForEach', ko.utils.arrayForEach); ko.exportSymbol('utils.arrayFirst', ko.utils.arrayFirst); ko.exportSymbol('utils.arrayFilter', ko.utils.arrayFilter); ko.exportSymbol('utils.arrayGetDistinctValues', ko.utils.arrayGetDistinctValues); ko.exportSymbol('utils.arrayIndexOf', ko.utils.arrayIndexOf); ko.exportSymbol('utils.arrayMap', ko.utils.arrayMap); ko.exportSymbol('utils.arrayPushAll', ko.utils.arrayPushAll); ko.exportSymbol('utils.arrayRemoveItem', ko.utils.arrayRemoveItem); ko.exportSymbol('utils.extend', ko.utils.extend); ko.exportSymbol('utils.fieldsIncludedWithJsonPost', ko.utils.fieldsIncludedWithJsonPost); ko.exportSymbol('utils.getFormFields', ko.utils.getFormFields); ko.exportSymbol('utils.postJson', ko.utils.postJson); ko.exportSymbol('utils.parseJson', ko.utils.parseJson); ko.exportSymbol('utils.registerEventHandler', ko.utils.registerEventHandler); ko.exportSymbol('utils.stringifyJson', ko.utils.stringifyJson); ko.exportSymbol('utils.range', ko.utils.range); ko.exportSymbol('utils.toggleDomNodeCssClass', ko.utils.toggleDomNodeCssClass); ko.exportSymbol('utils.triggerEvent', ko.utils.triggerEvent); ko.exportSymbol('utils.unwrapObservable', ko.utils.unwrapObservable); if (!Function.prototype['bind']) { Function.prototype['bind'] = function (object) { var originalFunction = this, args = Array.prototype.slice.call(arguments), object = args.shift(); return function () { return originalFunction.apply(object, args.concat(Array.prototype.slice.call(arguments))); }; }; }
        ko.utils.domData = new (function () {
            var uniqueId = 0; var dataStoreKeyExpandoPropertyName = "__ko__" + (new Date).getTime(); var dataStore = {}; return {
                get: function (node, key) { var allDataForNode = ko.utils.domData.getAll(node, false); return allDataForNode === undefined ? undefined : allDataForNode[key]; }, set: function (node, key, value) {
                    if (value === undefined) {
                        if (ko.utils.domData.getAll(node, false) === undefined)
                            return;
                    }
                    var allDataForNode = ko.utils.domData.getAll(node, true); allDataForNode[key] = value;
                }, getAll: function (node, createIfNotFound) {
                    var dataStoreKey = node[dataStoreKeyExpandoPropertyName]; var hasExistingDataStore = dataStoreKey && (dataStoreKey !== "null"); if (!hasExistingDataStore) {
                        if (!createIfNotFound)
                            return undefined; dataStoreKey = node[dataStoreKeyExpandoPropertyName] = "ko" + uniqueId++; dataStore[dataStoreKey] = {};
                    }
                    return dataStore[dataStoreKey];
                }, clear: function (node) { var dataStoreKey = node[dataStoreKeyExpandoPropertyName]; if (dataStoreKey) { delete dataStore[dataStoreKey]; node[dataStoreKeyExpandoPropertyName] = null; } }
            }
        })(); ko.exportSymbol('utils.domData', ko.utils.domData); ko.exportSymbol('utils.domData.clear', ko.utils.domData.clear); ko.utils.domNodeDisposal = new (function () {
            var domDataKey = "__ko_domNodeDisposal__" + (new Date).getTime(); var cleanableNodeTypes = { 1: true, 8: true, 9: true }; var cleanableNodeTypesWithDescendants = { 1: true, 9: true }; function getDisposeCallbacksCollection(node, createIfNotFound) {
                var allDisposeCallbacks = ko.utils.domData.get(node, domDataKey); if ((allDisposeCallbacks === undefined) && createIfNotFound) { allDisposeCallbacks = []; ko.utils.domData.set(node, domDataKey, allDisposeCallbacks); }
                return allDisposeCallbacks;
            }
            function destroyCallbacksCollection(node) { ko.utils.domData.set(node, domDataKey, undefined); }
            function cleanSingleNode(node) {
                var callbacks = getDisposeCallbacksCollection(node, false); if (callbacks) {
                    callbacks = callbacks.slice(0); for (var i = 0; i < callbacks.length; i++)
                        callbacks[i](node);
                }
                ko.utils.domData.clear(node); if ((typeof jQuery == "function") && (typeof jQuery['cleanData'] == "function"))
                    jQuery['cleanData']([node]); if (cleanableNodeTypesWithDescendants[node.nodeType])
                        cleanImmediateCommentTypeChildren(node);
            }
            function cleanImmediateCommentTypeChildren(nodeWithChildren) {
                var child, nextChild = nodeWithChildren.firstChild; while (child = nextChild) {
                    nextChild = child.nextSibling; if (child.nodeType === 8)
                        cleanSingleNode(child);
                }
            }
            return {
                addDisposeCallback: function (node, callback) {
                    if (typeof callback != "function")
                        throw new Error("Callback must be a function"); getDisposeCallbacksCollection(node, true).push(callback);
                }, removeDisposeCallback: function (node, callback) {
                    var callbacksCollection = getDisposeCallbacksCollection(node, false); if (callbacksCollection) {
                        ko.utils.arrayRemoveItem(callbacksCollection, callback); if (callbacksCollection.length == 0)
                            destroyCallbacksCollection(node);
                    }
                }, cleanNode: function (node) {
                    if (cleanableNodeTypes[node.nodeType]) {
                        cleanSingleNode(node); if (cleanableNodeTypesWithDescendants[node.nodeType]) {
                            var descendants = []; ko.utils.arrayPushAll(descendants, node.getElementsByTagName("*")); for (var i = 0, j = descendants.length; i < j; i++)
                                cleanSingleNode(descendants[i]);
                        }
                    }
                }, removeNode: function (node) {
                    ko.cleanNode(node); if (node.parentNode)
                        node.parentNode.removeChild(node);
                }
            }
        })(); ko.cleanNode = ko.utils.domNodeDisposal.cleanNode; ko.removeNode = ko.utils.domNodeDisposal.removeNode; ko.exportSymbol('cleanNode', ko.cleanNode); ko.exportSymbol('removeNode', ko.removeNode); ko.exportSymbol('utils.domNodeDisposal', ko.utils.domNodeDisposal); ko.exportSymbol('utils.domNodeDisposal.addDisposeCallback', ko.utils.domNodeDisposal.addDisposeCallback); ko.exportSymbol('utils.domNodeDisposal.removeDisposeCallback', ko.utils.domNodeDisposal.removeDisposeCallback); (function () {
            var leadingCommentRegex = /^(\s*)<!--(.*?)-->/; function simpleHtmlParse(html) {
                var tags = ko.utils.stringTrim(html).toLowerCase(), div = document.createElement("div"); var wrap = tags.match(/^<(thead|tbody|tfoot)/) && [1, "<table>", "</table>"] || !tags.indexOf("<tr") && [2, "<table><tbody>", "</tbody></table>"] || (!tags.indexOf("<td") || !tags.indexOf("<th")) && [3, "<table><tbody><tr>", "</tr></tbody></table>"] || [0, "", ""]; var markup = "ignored<div>" + wrap[1] + html + wrap[2] + "</div>"; if (typeof window['innerShiv'] == "function") { div.appendChild(window['innerShiv'](markup)); } else { div.innerHTML = markup; }
                while (wrap[0]--)
                    div = div.lastChild; return ko.utils.makeArray(div.lastChild.childNodes);
            }
            function jQueryHtmlParse(html) {
                var elems = jQuery['clean']([html]); if (elems && elems[0]) {
                    var elem = elems[0]; while (elem.parentNode && elem.parentNode.nodeType !== 11)
                        elem = elem.parentNode; if (elem.parentNode)
                            elem.parentNode.removeChild(elem);
                }
                return elems;
            }
            ko.utils.parseHtmlFragment = function (html) { return typeof jQuery != 'undefined' ? jQueryHtmlParse(html) : simpleHtmlParse(html); }; ko.utils.setHtml = function (node, html) {
                ko.utils.emptyDomNode(node); if ((html !== null) && (html !== undefined)) {
                    if (typeof html != 'string')
                        html = html.toString(); if (typeof jQuery != 'undefined') { jQuery(node)['html'](html); } else {
                            var parsedNodes = ko.utils.parseHtmlFragment(html); for (var i = 0; i < parsedNodes.length; i++)
                                node.appendChild(parsedNodes[i]);
                        }
                }
            };
        })(); ko.exportSymbol('utils.parseHtmlFragment', ko.utils.parseHtmlFragment); ko.exportSymbol('utils.setHtml', ko.utils.setHtml); ko.memoization = (function () {
            var memos = {}; function randomMax8HexChars() { return (((1 + Math.random()) * 0x100000000) | 0).toString(16).substring(1); }
            function generateRandomId() { return randomMax8HexChars() + randomMax8HexChars(); }
            function findMemoNodes(rootNode, appendToArray) {
                if (!rootNode)
                    return; if (rootNode.nodeType == 8) {
                        var memoId = ko.memoization.parseMemoText(rootNode.nodeValue); if (memoId != null)
                            appendToArray.push({ domNode: rootNode, memoId: memoId });
                    } else if (rootNode.nodeType == 1) {
                        for (var i = 0, childNodes = rootNode.childNodes, j = childNodes.length; i < j; i++)
                            findMemoNodes(childNodes[i], appendToArray);
                    }
            }
            return {
                memoize: function (callback) {
                    if (typeof callback != "function")
                        throw new Error("You can only pass a function to ko.memoization.memoize()"); var memoId = generateRandomId(); memos[memoId] = callback; return "<!--[ko_memo:" + memoId + "]-->";
                }, unmemoize: function (memoId, callbackParams) {
                    var callback = memos[memoId]; if (callback === undefined)
                        throw new Error("Couldn't find any memo with ID " + memoId + ". Perhaps it's already been unmemoized."); try { callback.apply(null, callbackParams || []); return true; }
                    finally { delete memos[memoId]; }
                }, unmemoizeDomNodeAndDescendants: function (domNode, extraCallbackParamsArray) {
                    var memos = []; findMemoNodes(domNode, memos); for (var i = 0, j = memos.length; i < j; i++) {
                        var node = memos[i].domNode; var combinedParams = [node]; if (extraCallbackParamsArray)
                            ko.utils.arrayPushAll(combinedParams, extraCallbackParamsArray); ko.memoization.unmemoize(memos[i].memoId, combinedParams); node.nodeValue = ""; if (node.parentNode)
                                node.parentNode.removeChild(node);
                    }
                }, parseMemoText: function (memoText) { var match = memoText.match(/^\[ko_memo\:(.*?)\]$/); return match ? match[1] : null; }
            };
        })(); ko.exportSymbol('memoization', ko.memoization); ko.exportSymbol('memoization.memoize', ko.memoization.memoize); ko.exportSymbol('memoization.unmemoize', ko.memoization.unmemoize); ko.exportSymbol('memoization.parseMemoText', ko.memoization.parseMemoText); ko.exportSymbol('memoization.unmemoizeDomNodeAndDescendants', ko.memoization.unmemoizeDomNodeAndDescendants); ko.extenders = { 'throttle': function (target, timeout) { target['throttleEvaluation'] = timeout; var writeTimeoutInstance = null; return ko.dependentObservable({ 'read': target, 'write': function (value) { clearTimeout(writeTimeoutInstance); writeTimeoutInstance = setTimeout(function () { target(value); }, timeout); } }); }, 'notify': function (target, notifyWhen) { target["equalityComparer"] = notifyWhen == "always" ? function () { return false } : ko.observable["fn"]["equalityComparer"]; return target; } }; function applyExtenders(requestedExtenders) {
            var target = this; if (requestedExtenders) { for (var key in requestedExtenders) { var extenderHandler = ko.extenders[key]; if (typeof extenderHandler == 'function') { target = extenderHandler(target, requestedExtenders[key]); } } }
            return target;
        }
        ko.exportSymbol('extenders', ko.extenders); ko.subscription = function (target, callback, disposeCallback) { this.target = target; this.callback = callback; this.disposeCallback = disposeCallback; ko.exportProperty(this, 'dispose', this.dispose); }; ko.subscription.prototype.dispose = function () { this.isDisposed = true; this.disposeCallback(); }; ko.subscribable = function () { this._subscriptions = {}; ko.utils.extend(this, ko.subscribable['fn']); ko.exportProperty(this, 'subscribe', this.subscribe); ko.exportProperty(this, 'extend', this.extend); ko.exportProperty(this, 'getSubscriptionsCount', this.getSubscriptionsCount); }
        var defaultEvent = "change"; ko.subscribable['fn'] = {
            subscribe: function (callback, callbackTarget, event) {
                event = event || defaultEvent; var boundCallback = callbackTarget ? callback.bind(callbackTarget) : callback; var subscription = new ko.subscription(this, boundCallback, function () { ko.utils.arrayRemoveItem(this._subscriptions[event], subscription); }.bind(this)); if (!this._subscriptions[event])
                    this._subscriptions[event] = []; this._subscriptions[event].push(subscription); return subscription;
            }, "notifySubscribers": function (valueToNotify, event) {
                event = event || defaultEvent; if (this._subscriptions[event]) {
                    ko.utils.arrayForEach(this._subscriptions[event].slice(0), function (subscription) {
                        if (subscription && (subscription.isDisposed !== true))
                            subscription.callback(valueToNotify);
                    });
                }
            }, getSubscriptionsCount: function () {
                var total = 0; for (var eventName in this._subscriptions) {
                    if (this._subscriptions.hasOwnProperty(eventName))
                        total += this._subscriptions[eventName].length;
                }
                return total;
            }, extend: applyExtenders
        }; ko.isSubscribable = function (instance) { return typeof instance.subscribe == "function" && typeof instance["notifySubscribers"] == "function"; }; ko.exportSymbol('subscribable', ko.subscribable); ko.exportSymbol('isSubscribable', ko.isSubscribable); ko.dependencyDetection = (function () {
            var _frames = []; return {
                begin: function (callback) { _frames.push({ callback: callback, distinctDependencies: [] }); }, end: function () { _frames.pop(); }, registerDependency: function (subscribable) {
                    if (!ko.isSubscribable(subscribable))
                        throw new Error("Only subscribable things can act as dependencies"); if (_frames.length > 0) {
                            var topFrame = _frames[_frames.length - 1]; if (ko.utils.arrayIndexOf(topFrame.distinctDependencies, subscribable) >= 0)
                                return; topFrame.distinctDependencies.push(subscribable); topFrame.callback(subscribable);
                        }
                }
            };
        })(); var primitiveTypes = { 'undefined': true, 'boolean': true, 'number': true, 'string': true }; ko.observable = function (initialValue) {
            var _latestValue = initialValue; function observable() {
                if (arguments.length > 0) {
                    if ((!observable['equalityComparer']) || !observable['equalityComparer'](_latestValue, arguments[0])) { observable.valueWillMutate(); _latestValue = arguments[0]; if (DEBUG) observable._latestValue = _latestValue; observable.valueHasMutated(); }
                    return this;
                }
                else { ko.dependencyDetection.registerDependency(observable); return _latestValue; }
            }
            if (DEBUG) observable._latestValue = _latestValue; ko.subscribable.call(observable); observable.valueHasMutated = function () { observable["notifySubscribers"](_latestValue); }
            observable.valueWillMutate = function () { observable["notifySubscribers"](_latestValue, "beforeChange"); }
            ko.utils.extend(observable, ko.observable['fn']); ko.exportProperty(observable, "valueHasMutated", observable.valueHasMutated); ko.exportProperty(observable, "valueWillMutate", observable.valueWillMutate); return observable;
        }
        ko.observable['fn'] = { "equalityComparer": function valuesArePrimitiveAndEqual(a, b) { var oldValueIsPrimitive = (a === null) || (typeof (a) in primitiveTypes); return oldValueIsPrimitive ? (a === b) : false; } }; var protoProperty = ko.observable.protoProperty = "__ko_proto__"; ko.observable['fn'][protoProperty] = ko.observable; ko.hasPrototype = function (instance, prototype) { if ((instance === null) || (instance === undefined) || (instance[protoProperty] === undefined)) return false; if (instance[protoProperty] === prototype) return true; return ko.hasPrototype(instance[protoProperty], prototype); }; ko.isObservable = function (instance) { return ko.hasPrototype(instance, ko.observable); }
        ko.isWriteableObservable = function (instance) {
            if ((typeof instance == "function") && instance[protoProperty] === ko.observable)
                return true; if ((typeof instance == "function") && (instance[protoProperty] === ko.dependentObservable) && (instance.hasWriteFunction))
                    return true; return false;
        }
        ko.exportSymbol('observable', ko.observable); ko.exportSymbol('isObservable', ko.isObservable); ko.exportSymbol('isWriteableObservable', ko.isWriteableObservable); ko.observableArray = function (initialValues) {
            if (arguments.length == 0) { initialValues = []; }
            if ((initialValues !== null) && (initialValues !== undefined) && !('length' in initialValues))
                throw new Error("The argument passed when initializing an observable array must be an array, or null, or undefined."); var result = ko.observable(initialValues); ko.utils.extend(result, ko.observableArray['fn']); return result;
        }
        ko.observableArray['fn'] = {
            'remove': function (valueOrPredicate) {
                var underlyingArray = this(); var removedValues = []; var predicate = typeof valueOrPredicate == "function" ? valueOrPredicate : function (value) { return value === valueOrPredicate; }; for (var i = 0; i < underlyingArray.length; i++) {
                    var value = underlyingArray[i]; if (predicate(value)) {
                        if (removedValues.length === 0) { this.valueWillMutate(); }
                        removedValues.push(value); underlyingArray.splice(i, 1); i--;
                    }
                }
                if (removedValues.length) { this.valueHasMutated(); }
                return removedValues;
            }, 'removeAll': function (arrayOfValues) {
                if (arrayOfValues === undefined) { var underlyingArray = this(); var allValues = underlyingArray.slice(0); this.valueWillMutate(); underlyingArray.splice(0, underlyingArray.length); this.valueHasMutated(); return allValues; }
                if (!arrayOfValues)
                    return []; return this['remove'](function (value) { return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0; });
            }, 'destroy': function (valueOrPredicate) {
                var underlyingArray = this(); var predicate = typeof valueOrPredicate == "function" ? valueOrPredicate : function (value) { return value === valueOrPredicate; }; this.valueWillMutate(); for (var i = underlyingArray.length - 1; i >= 0; i--) {
                    var value = underlyingArray[i]; if (predicate(value))
                        underlyingArray[i]["_destroy"] = true;
                }
                this.valueHasMutated();
            }, 'destroyAll': function (arrayOfValues) {
                if (arrayOfValues === undefined)
                    return this['destroy'](function () { return true }); if (!arrayOfValues)
                        return []; return this['destroy'](function (value) { return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0; });
            }, 'indexOf': function (item) { var underlyingArray = this(); return ko.utils.arrayIndexOf(underlyingArray, item); }, 'replace': function (oldItem, newItem) { var index = this['indexOf'](oldItem); if (index >= 0) { this.valueWillMutate(); this()[index] = newItem; this.valueHasMutated(); } }
        }
        ko.utils.arrayForEach(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (methodName) { ko.observableArray['fn'][methodName] = function () { var underlyingArray = this(); this.valueWillMutate(); var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments); this.valueHasMutated(); return methodCallResult; }; }); ko.utils.arrayForEach(["slice"], function (methodName) { ko.observableArray['fn'][methodName] = function () { var underlyingArray = this(); return underlyingArray[methodName].apply(underlyingArray, arguments); }; }); ko.exportSymbol('observableArray', ko.observableArray); ko.dependentObservable = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {
            var _latestValue, _hasBeenEvaluated = false, _isBeingEvaluated = false, readFunction = evaluatorFunctionOrOptions; if (readFunction && typeof readFunction == "object") { options = readFunction; readFunction = options["read"]; } else {
                options = options || {}; if (!readFunction)
                    readFunction = options["read"];
            }
            if (typeof readFunction != "function")
                throw new Error("Pass a function that returns the value of the ko.computed"); var writeFunction = options["write"]; if (!evaluatorFunctionTarget)
                    evaluatorFunctionTarget = options["owner"]; var _subscriptionsToDependencies = []; function disposeAllSubscriptionsToDependencies() { ko.utils.arrayForEach(_subscriptionsToDependencies, function (subscription) { subscription.dispose(); }); _subscriptionsToDependencies = []; }
            var dispose = disposeAllSubscriptionsToDependencies; var disposeWhenNodeIsRemoved = (typeof options["disposeWhenNodeIsRemoved"] == "object") ? options["disposeWhenNodeIsRemoved"] : null; var disposeWhen = options["disposeWhen"] || function () { return false; }; if (disposeWhenNodeIsRemoved) { dispose = function () { ko.utils.domNodeDisposal.removeDisposeCallback(disposeWhenNodeIsRemoved, arguments.callee); disposeAllSubscriptionsToDependencies(); }; ko.utils.domNodeDisposal.addDisposeCallback(disposeWhenNodeIsRemoved, dispose); var existingDisposeWhenFunction = disposeWhen; disposeWhen = function () { return !ko.utils.domNodeIsAttachedToDocument(disposeWhenNodeIsRemoved) || existingDisposeWhenFunction(); } }
            var evaluationTimeoutInstance = null; function evaluatePossiblyAsync() {
                var throttleEvaluationTimeout = dependentObservable['throttleEvaluation']; if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) { clearTimeout(evaluationTimeoutInstance); evaluationTimeoutInstance = setTimeout(evaluateImmediate, throttleEvaluationTimeout); } else
                    evaluateImmediate();
            }
            function evaluateImmediate() {
                if (_isBeingEvaluated) { return; }
                if (_hasBeenEvaluated && disposeWhen()) { dispose(); return; }
                _isBeingEvaluated = true; try {
                    var disposalCandidates = ko.utils.arrayMap(_subscriptionsToDependencies, function (item) { return item.target; }); ko.dependencyDetection.begin(function (subscribable) {
                        var inOld; if ((inOld = ko.utils.arrayIndexOf(disposalCandidates, subscribable)) >= 0)
                            disposalCandidates[inOld] = undefined; else
                            _subscriptionsToDependencies.push(subscribable.subscribe(evaluatePossiblyAsync));
                    }); var newValue = readFunction.call(evaluatorFunctionTarget); for (var i = disposalCandidates.length - 1; i >= 0; i--) {
                        if (disposalCandidates[i])
                            _subscriptionsToDependencies.splice(i, 1)[0].dispose();
                    }
                    _hasBeenEvaluated = true; dependentObservable["notifySubscribers"](_latestValue, "beforeChange"); _latestValue = newValue; if (DEBUG) dependentObservable._latestValue = _latestValue;
                } finally { ko.dependencyDetection.end(); }
                dependentObservable["notifySubscribers"](_latestValue); _isBeingEvaluated = false;
            }
            function dependentObservable() { if (arguments.length > 0) { set.apply(dependentObservable, arguments); } else { return get(); } }
            function set() { if (typeof writeFunction === "function") { writeFunction.apply(evaluatorFunctionTarget, arguments); } else { throw new Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters."); } }
            function get() {
                if (!_hasBeenEvaluated)
                    evaluateImmediate(); ko.dependencyDetection.registerDependency(dependentObservable); return _latestValue;
            }
            dependentObservable.getDependenciesCount = function () { return _subscriptionsToDependencies.length; }; dependentObservable.hasWriteFunction = typeof options["write"] === "function"; dependentObservable.dispose = function () { dispose(); }; ko.subscribable.call(dependentObservable); ko.utils.extend(dependentObservable, ko.dependentObservable['fn']); if (options['deferEvaluation'] !== true)
                evaluateImmediate(); ko.exportProperty(dependentObservable, 'dispose', dependentObservable.dispose); ko.exportProperty(dependentObservable, 'getDependenciesCount', dependentObservable.getDependenciesCount); return dependentObservable;
        }; ko.isComputed = function (instance) { return ko.hasPrototype(instance, ko.dependentObservable); }; var protoProp = ko.observable.protoProperty; ko.dependentObservable[protoProp] = ko.observable; ko.dependentObservable['fn'] = {}; ko.dependentObservable['fn'][protoProp] = ko.dependentObservable; ko.exportSymbol('dependentObservable', ko.dependentObservable); ko.exportSymbol('computed', ko.dependentObservable); ko.exportSymbol('isComputed', ko.isComputed); (function () {
            var maxNestedObservableDepth = 10; ko.toJS = function (rootObject) {
                if (arguments.length == 0)
                    throw new Error("When calling ko.toJS, pass the object you want to convert."); return mapJsObjectGraph(rootObject, function (valueToMap) {
                        for (var i = 0; ko.isObservable(valueToMap) && (i < maxNestedObservableDepth) ; i++)
                            valueToMap = valueToMap(); return valueToMap;
                    });
            }; ko.toJSON = function (rootObject, replacer, space) { var plainJavaScriptObject = ko.toJS(rootObject); return ko.utils.stringifyJson(plainJavaScriptObject, replacer, space); }; function mapJsObjectGraph(rootObject, mapInputCallback, visitedObjects) {
                visitedObjects = visitedObjects || new objectLookup(); rootObject = mapInputCallback(rootObject); var canHaveProperties = (typeof rootObject == "object") && (rootObject !== null) && (rootObject !== undefined) && (!(rootObject instanceof Date)); if (!canHaveProperties)
                    return rootObject; var outputProperties = rootObject instanceof Array ? [] : {}; visitedObjects.save(rootObject, outputProperties); visitPropertiesOrArrayEntries(rootObject, function (indexer) { var propertyValue = mapInputCallback(rootObject[indexer]); switch (typeof propertyValue) { case "boolean": case "number": case "string": case "function": outputProperties[indexer] = propertyValue; break; case "object": case "undefined": var previouslyMappedValue = visitedObjects.get(propertyValue); outputProperties[indexer] = (previouslyMappedValue !== undefined) ? previouslyMappedValue : mapJsObjectGraph(propertyValue, mapInputCallback, visitedObjects); break; } }); return outputProperties;
            }
            function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {
                if (rootObject instanceof Array) {
                    for (var i = 0; i < rootObject.length; i++)
                        visitorCallback(i); if (typeof rootObject['toJSON'] == 'function')
                            visitorCallback('toJSON');
                } else {
                    for (var propertyName in rootObject)
                        visitorCallback(propertyName);
                }
            }; function objectLookup() {
                var keys = []; var values = []; this.save = function (key, value) {
                    var existingIndex = ko.utils.arrayIndexOf(keys, key); if (existingIndex >= 0)
                        values[existingIndex] = value; else { keys.push(key); values.push(value); }
                }; this.get = function (key) { var existingIndex = ko.utils.arrayIndexOf(keys, key); return (existingIndex >= 0) ? values[existingIndex] : undefined; };
            };
        })(); ko.exportSymbol('toJS', ko.toJS); ko.exportSymbol('toJSON', ko.toJSON); (function () {
            var hasDomDataExpandoProperty = '__ko__hasDomDataOptionValue__'; ko.selectExtensions = {
                readValue: function (element) {
                    switch (ko.utils.tagNameLower(element)) {
                        case 'option': if (element[hasDomDataExpandoProperty] === true)
                            return ko.utils.domData.get(element, ko.bindingHandlers.options.optionValueDomDataKey); return element.getAttribute("value"); case 'select': return element.selectedIndex >= 0 ? ko.selectExtensions.readValue(element.options[element.selectedIndex]) : undefined; default: return element.value;
                    }
                }, writeValue: function (element, value) {
                    switch (ko.utils.tagNameLower(element)) {
                        case 'option': switch (typeof value) {
                            case "string": ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, undefined); if (hasDomDataExpandoProperty in element) { delete element[hasDomDataExpandoProperty]; }
                                element.value = value; break; default: ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, value); element[hasDomDataExpandoProperty] = true; element.value = typeof value === "number" ? value : ""; break;
                        }
                            break; case 'select': for (var i = element.options.length - 1; i >= 0; i--) { if (ko.selectExtensions.readValue(element.options[i]) == value) { element.selectedIndex = i; break; } }
                                break; default: if ((value === null) || (value === undefined))
                                    value = ""; element.value = value; break;
                    }
                }
            };
        })(); ko.exportSymbol('selectExtensions', ko.selectExtensions); ko.exportSymbol('selectExtensions.readValue', ko.selectExtensions.readValue); ko.exportSymbol('selectExtensions.writeValue', ko.selectExtensions.writeValue); ko.jsonExpressionRewriting = (function () {
            var restoreCapturedTokensRegex = /\@ko_token_(\d+)\@/g; var javaScriptAssignmentTarget = /^[\_$a-z][\_$a-z0-9]*(\[.*?\])*(\.[\_$a-z][\_$a-z0-9]*(\[.*?\])*)*$/i; var javaScriptReservedWords = ["true", "false"]; function restoreTokens(string, tokens) {
                var prevValue = null; while (string != prevValue) { prevValue = string; string = string.replace(restoreCapturedTokensRegex, function (match, tokenIndex) { return tokens[tokenIndex]; }); }
                return string;
            }
            function isWriteableValue(expression) {
                if (ko.utils.arrayIndexOf(javaScriptReservedWords, ko.utils.stringTrim(expression).toLowerCase()) >= 0)
                    return false; return expression.match(javaScriptAssignmentTarget) !== null;
            }
            function ensureQuoted(key) { var trimmedKey = ko.utils.stringTrim(key); switch (trimmedKey.length && trimmedKey.charAt(0)) { case "'": case '"': return key; default: return "'" + trimmedKey + "'"; } }
            return {
                bindingRewriteValidators: [], parseObjectLiteral: function (objectLiteralString) {
                    var str = ko.utils.stringTrim(objectLiteralString); if (str.length < 3)
                        return []; if (str.charAt(0) === "{")
                            str = str.substring(1, str.length - 1); var tokens = []; var tokenStart = null, tokenEndChar; for (var position = 0; position < str.length; position++) { var c = str.charAt(position); if (tokenStart === null) { switch (c) { case '"': case "'": case "/": tokenStart = position; tokenEndChar = c; break; } } else if ((c == tokenEndChar) && (str.charAt(position - 1) !== "\\")) { var token = str.substring(tokenStart, position + 1); tokens.push(token); var replacement = "@ko_token_" + (tokens.length - 1) + "@"; str = str.substring(0, tokenStart) + replacement + str.substring(position + 1); position -= (token.length - replacement.length); tokenStart = null; } }
                    tokenStart = null; tokenEndChar = null; var tokenDepth = 0, tokenStartChar = null; for (var position = 0; position < str.length; position++) {
                        var c = str.charAt(position); if (tokenStart === null) { switch (c) { case "{": tokenStart = position; tokenStartChar = c; tokenEndChar = "}"; break; case "(": tokenStart = position; tokenStartChar = c; tokenEndChar = ")"; break; case "[": tokenStart = position; tokenStartChar = c; tokenEndChar = "]"; break; } }
                        if (c === tokenStartChar)
                            tokenDepth++; else if (c === tokenEndChar) { tokenDepth--; if (tokenDepth === 0) { var token = str.substring(tokenStart, position + 1); tokens.push(token); var replacement = "@ko_token_" + (tokens.length - 1) + "@"; str = str.substring(0, tokenStart) + replacement + str.substring(position + 1); position -= (token.length - replacement.length); tokenStart = null; } }
                    }
                    var result = []; var keyValuePairs = str.split(","); for (var i = 0, j = keyValuePairs.length; i < j; i++) { var pair = keyValuePairs[i]; var colonPos = pair.indexOf(":"); if ((colonPos > 0) && (colonPos < pair.length - 1)) { var key = pair.substring(0, colonPos); var value = pair.substring(colonPos + 1); result.push({ 'key': restoreTokens(key, tokens), 'value': restoreTokens(value, tokens) }); } else { result.push({ 'unknown': restoreTokens(pair, tokens) }); } }
                    return result;
                }, insertPropertyAccessorsIntoJson: function (objectLiteralStringOrKeyValueArray) {
                    var keyValueArray = typeof objectLiteralStringOrKeyValueArray === "string" ? ko.jsonExpressionRewriting.parseObjectLiteral(objectLiteralStringOrKeyValueArray) : objectLiteralStringOrKeyValueArray; var resultStrings = [], propertyAccessorResultStrings = []; var keyValueEntry; for (var i = 0; keyValueEntry = keyValueArray[i]; i++) {
                        if (resultStrings.length > 0)
                            resultStrings.push(","); if (keyValueEntry['key']) {
                                var quotedKey = ensureQuoted(keyValueEntry['key']), val = keyValueEntry['value']; resultStrings.push(quotedKey); resultStrings.push(":"); resultStrings.push(val); if (isWriteableValue(ko.utils.stringTrim(val))) {
                                    if (propertyAccessorResultStrings.length > 0)
                                        propertyAccessorResultStrings.push(", "); propertyAccessorResultStrings.push(quotedKey + " : function(__ko_value) { " + val + " = __ko_value; }");
                                }
                            } else if (keyValueEntry['unknown']) { resultStrings.push(keyValueEntry['unknown']); }
                    }
                    var combinedResult = resultStrings.join(""); if (propertyAccessorResultStrings.length > 0) { var allPropertyAccessors = propertyAccessorResultStrings.join(""); combinedResult = combinedResult + ", '_ko_property_writers' : { " + allPropertyAccessors + " } "; }
                    return combinedResult;
                }, keyValueArrayContainsKey: function (keyValueArray, key) {
                    for (var i = 0; i < keyValueArray.length; i++)
                        if (ko.utils.stringTrim(keyValueArray[i]['key']) == key)
                            return true; return false;
                }, writeValueToProperty: function (property, allBindingsAccessor, key, value, checkIfDifferent) {
                    if (!property || !ko.isWriteableObservable(property)) {
                        var propWriters = allBindingsAccessor()['_ko_property_writers']; if (propWriters && propWriters[key])
                            propWriters[key](value);
                    } else if (!checkIfDifferent || property() !== value) { property(value); }
                }
            };
        })(); ko.exportSymbol('jsonExpressionRewriting', ko.jsonExpressionRewriting); ko.exportSymbol('jsonExpressionRewriting.bindingRewriteValidators', ko.jsonExpressionRewriting.bindingRewriteValidators); ko.exportSymbol('jsonExpressionRewriting.parseObjectLiteral', ko.jsonExpressionRewriting.parseObjectLiteral); ko.exportSymbol('jsonExpressionRewriting.insertPropertyAccessorsIntoJson', ko.jsonExpressionRewriting.insertPropertyAccessorsIntoJson); (function () {
            var commentNodesHaveTextProperty = document.createComment("test").text === "<!--test-->"; var startCommentRegex = commentNodesHaveTextProperty ? /^<!--\s*ko\s+(.*\:.*)\s*-->$/ : /^\s*ko\s+(.*\:.*)\s*$/; var endCommentRegex = commentNodesHaveTextProperty ? /^<!--\s*\/ko\s*-->$/ : /^\s*\/ko\s*$/; var htmlTagsWithOptionallyClosingChildren = { 'ul': true, 'ol': true }; function isStartComment(node) { return (node.nodeType == 8) && (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(startCommentRegex); }
            function isEndComment(node) { return (node.nodeType == 8) && (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(endCommentRegex); }
            function getVirtualChildren(startComment, allowUnbalanced) {
                var currentNode = startComment; var depth = 1; var children = []; while (currentNode = currentNode.nextSibling) {
                    if (isEndComment(currentNode)) {
                        depth--; if (depth === 0)
                            return children;
                    }
                    children.push(currentNode); if (isStartComment(currentNode))
                        depth++;
                }
                if (!allowUnbalanced)
                    throw new Error("Cannot find closing comment tag to match: " + startComment.nodeValue); return null;
            }
            function getMatchingEndComment(startComment, allowUnbalanced) {
                var allVirtualChildren = getVirtualChildren(startComment, allowUnbalanced); if (allVirtualChildren) {
                    if (allVirtualChildren.length > 0)
                        return allVirtualChildren[allVirtualChildren.length - 1].nextSibling; return startComment.nextSibling;
                } else
                    return null;
            }
            function getUnbalancedChildTags(node) {
                var childNode = node.firstChild, captureRemaining = null; if (childNode) {
                    do {
                        if (captureRemaining)
                            captureRemaining.push(childNode); else if (isStartComment(childNode)) {
                                var matchingEndComment = getMatchingEndComment(childNode, true); if (matchingEndComment)
                                    childNode = matchingEndComment; else
                                    captureRemaining = [childNode];
                            } else if (isEndComment(childNode)) { captureRemaining = [childNode]; }
                    } while (childNode = childNode.nextSibling);
                }
                return captureRemaining;
            }
            ko.virtualElements = {
                allowedBindings: {}, childNodes: function (node) { return isStartComment(node) ? getVirtualChildren(node) : node.childNodes; }, emptyNode: function (node) {
                    if (!isStartComment(node))
                        ko.utils.emptyDomNode(node); else {
                        var virtualChildren = ko.virtualElements.childNodes(node); for (var i = 0, j = virtualChildren.length; i < j; i++)
                            ko.removeNode(virtualChildren[i]);
                    }
                }, setDomNodeChildren: function (node, childNodes) {
                    if (!isStartComment(node))
                        ko.utils.setDomNodeChildren(node, childNodes); else {
                        ko.virtualElements.emptyNode(node); var endCommentNode = node.nextSibling; for (var i = 0, j = childNodes.length; i < j; i++)
                            endCommentNode.parentNode.insertBefore(childNodes[i], endCommentNode);
                    }
                }, prepend: function (containerNode, nodeToPrepend) {
                    if (!isStartComment(containerNode)) {
                        if (containerNode.firstChild)
                            containerNode.insertBefore(nodeToPrepend, containerNode.firstChild); else
                            containerNode.appendChild(nodeToPrepend);
                    } else { containerNode.parentNode.insertBefore(nodeToPrepend, containerNode.nextSibling); }
                }, insertAfter: function (containerNode, nodeToInsert, insertAfterNode) {
                    if (!isStartComment(containerNode)) {
                        if (insertAfterNode.nextSibling)
                            containerNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling); else
                            containerNode.appendChild(nodeToInsert);
                    } else { containerNode.parentNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling); }
                }, firstChild: function (node) {
                    if (!isStartComment(node))
                        return node.firstChild; if (!node.nextSibling || isEndComment(node.nextSibling))
                            return null; return node.nextSibling;
                }, nextSibling: function (node) {
                    if (isStartComment(node))
                        node = getMatchingEndComment(node); if (node.nextSibling && isEndComment(node.nextSibling))
                            return null; return node.nextSibling;
                }, virtualNodeBindingValue: function (node) { var regexMatch = isStartComment(node); return regexMatch ? regexMatch[1] : null; }, normaliseVirtualElementDomStructure: function (elementVerified) {
                    if (!htmlTagsWithOptionallyClosingChildren[ko.utils.tagNameLower(elementVerified)])
                        return; var childNode = elementVerified.firstChild; if (childNode) {
                            do {
                                if (childNode.nodeType === 1) {
                                    var unbalancedTags = getUnbalancedChildTags(childNode); if (unbalancedTags) {
                                        var nodeToInsertBefore = childNode.nextSibling; for (var i = 0; i < unbalancedTags.length; i++) {
                                            if (nodeToInsertBefore)
                                                elementVerified.insertBefore(unbalancedTags[i], nodeToInsertBefore); else
                                                elementVerified.appendChild(unbalancedTags[i]);
                                        }
                                    }
                                }
                            } while (childNode = childNode.nextSibling);
                        }
                }
            };
        })(); ko.exportSymbol('virtualElements', ko.virtualElements); ko.exportSymbol('virtualElements.allowedBindings', ko.virtualElements.allowedBindings); ko.exportSymbol('virtualElements.emptyNode', ko.virtualElements.emptyNode); ko.exportSymbol('virtualElements.insertAfter', ko.virtualElements.insertAfter); ko.exportSymbol('virtualElements.prepend', ko.virtualElements.prepend); ko.exportSymbol('virtualElements.setDomNodeChildren', ko.virtualElements.setDomNodeChildren); (function () {
            var defaultBindingAttributeName = "data-bind"; ko.bindingProvider = function () { this.bindingCache = {}; }; ko.utils.extend(ko.bindingProvider.prototype, { 'nodeHasBindings': function (node) { switch (node.nodeType) { case 1: return node.getAttribute(defaultBindingAttributeName) != null; case 8: return ko.virtualElements.virtualNodeBindingValue(node) != null; default: return false; } }, 'getBindings': function (node, bindingContext) { var bindingsString = this['getBindingsString'](node, bindingContext); return bindingsString ? this['parseBindingsString'](bindingsString, bindingContext) : null; }, 'getBindingsString': function (node, bindingContext) { switch (node.nodeType) { case 1: return node.getAttribute(defaultBindingAttributeName); case 8: return ko.virtualElements.virtualNodeBindingValue(node); default: return null; } }, 'parseBindingsString': function (bindingsString, bindingContext) { try { var viewModel = bindingContext['$data'], scopes = (typeof viewModel == 'object' && viewModel != null) ? [viewModel, bindingContext] : [bindingContext], bindingFunction = createBindingsStringEvaluatorViaCache(bindingsString, scopes.length, this.bindingCache); return bindingFunction(scopes); } catch (ex) { throw new Error("Unable to parse bindings.\nMessage: " + ex + ";\nBindings value: " + bindingsString); } } }); ko.bindingProvider['instance'] = new ko.bindingProvider(); function createBindingsStringEvaluatorViaCache(bindingsString, scopesCount, cache) { var cacheKey = scopesCount + '_' + bindingsString; return cache[cacheKey] || (cache[cacheKey] = createBindingsStringEvaluator(bindingsString, scopesCount)); }
            function createBindingsStringEvaluator(bindingsString, scopesCount) { var rewrittenBindings = " { " + ko.jsonExpressionRewriting.insertPropertyAccessorsIntoJson(bindingsString) + " } "; return ko.utils.buildEvalWithinScopeFunction(rewrittenBindings, scopesCount); }
        })(); ko.exportSymbol('bindingProvider', ko.bindingProvider); (function () {
            ko.bindingHandlers = {}; ko.bindingContext = function (dataItem, parentBindingContext) {
                if (parentBindingContext) { ko.utils.extend(this, parentBindingContext); this['$parentContext'] = parentBindingContext; this['$parent'] = parentBindingContext['$data']; this['$parents'] = (parentBindingContext['$parents'] || []).slice(0); this['$parents'].unshift(this['$parent']); } else { this['$parents'] = []; this['$root'] = dataItem; }
                this['$data'] = dataItem;
            }
            ko.bindingContext.prototype['createChildContext'] = function (dataItem) { return new ko.bindingContext(dataItem, this); }; ko.bindingContext.prototype['extend'] = function (properties) { var clone = ko.utils.extend(new ko.bindingContext(), this); return ko.utils.extend(clone, properties); }; function validateThatBindingIsAllowedForVirtualElements(bindingName) {
                var validator = ko.virtualElements.allowedBindings[bindingName]; if (!validator)
                    throw new Error("The binding '" + bindingName + "' cannot be used with virtual elements")
            }
            function applyBindingsToDescendantsInternal(viewModel, elementOrVirtualElement, bindingContextsMayDifferFromDomParentElement) { var currentChild, nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement); while (currentChild = nextInQueue) { nextInQueue = ko.virtualElements.nextSibling(currentChild); applyBindingsToNodeAndDescendantsInternal(viewModel, currentChild, bindingContextsMayDifferFromDomParentElement); } }
            function applyBindingsToNodeAndDescendantsInternal(viewModel, nodeVerified, bindingContextMayDifferFromDomParentElement) {
                var shouldBindDescendants = true; var isElement = (nodeVerified.nodeType === 1); if (isElement)
                    ko.virtualElements.normaliseVirtualElementDomStructure(nodeVerified); var shouldApplyBindings = (isElement && bindingContextMayDifferFromDomParentElement) || ko.bindingProvider['instance']['nodeHasBindings'](nodeVerified); if (shouldApplyBindings)
                        shouldBindDescendants = applyBindingsToNodeInternal(nodeVerified, null, viewModel, bindingContextMayDifferFromDomParentElement).shouldBindDescendants; if (shouldBindDescendants) { applyBindingsToDescendantsInternal(viewModel, nodeVerified, !isElement); }
            }
            function applyBindingsToNodeInternal(node, bindings, viewModelOrBindingContext, bindingContextMayDifferFromDomParentElement) {
                var initPhase = 0; var parsedBindings; function makeValueAccessor(bindingKey) { return function () { return parsedBindings[bindingKey] } }
                function parsedBindingsAccessor() { return parsedBindings; }
                var bindingHandlerThatControlsDescendantBindings; ko.dependentObservable(function () {
                    var bindingContextInstance = viewModelOrBindingContext && (viewModelOrBindingContext instanceof ko.bindingContext) ? viewModelOrBindingContext : new ko.bindingContext(ko.utils.unwrapObservable(viewModelOrBindingContext)); var viewModel = bindingContextInstance['$data']; if (bindingContextMayDifferFromDomParentElement)
                        ko.storedBindingContextForNode(node, bindingContextInstance); var evaluatedBindings = (typeof bindings == "function") ? bindings() : bindings; parsedBindings = evaluatedBindings || ko.bindingProvider['instance']['getBindings'](node, bindingContextInstance); if (parsedBindings) {
                            if (initPhase === 0) {
                                initPhase = 1; for (var bindingKey in parsedBindings) {
                                    var binding = ko.bindingHandlers[bindingKey]; if (binding && node.nodeType === 8)
                                        validateThatBindingIsAllowedForVirtualElements(bindingKey); if (binding && typeof binding["init"] == "function") {
                                            var handlerInitFn = binding["init"]; var initResult = handlerInitFn(node, makeValueAccessor(bindingKey), parsedBindingsAccessor, viewModel, bindingContextInstance); if (initResult && initResult['controlsDescendantBindings']) {
                                                if (bindingHandlerThatControlsDescendantBindings !== undefined)
                                                    throw new Error("Multiple bindings (" + bindingHandlerThatControlsDescendantBindings + " and " + bindingKey + ") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element."); bindingHandlerThatControlsDescendantBindings = bindingKey;
                                            }
                                        }
                                }
                                initPhase = 2;
                            }
                            if (initPhase === 2) { for (var bindingKey in parsedBindings) { var binding = ko.bindingHandlers[bindingKey]; if (binding && typeof binding["update"] == "function") { var handlerUpdateFn = binding["update"]; handlerUpdateFn(node, makeValueAccessor(bindingKey), parsedBindingsAccessor, viewModel, bindingContextInstance); } } }
                        }
                }, null, { 'disposeWhenNodeIsRemoved': node }); return { shouldBindDescendants: bindingHandlerThatControlsDescendantBindings === undefined };
            }; var storedBindingContextDomDataKey = "__ko_bindingContext__"; ko.storedBindingContextForNode = function (node, bindingContext) {
                if (arguments.length == 2)
                    ko.utils.domData.set(node, storedBindingContextDomDataKey, bindingContext); else
                    return ko.utils.domData.get(node, storedBindingContextDomDataKey);
            }
            ko.applyBindingsToNode = function (node, bindings, viewModel) {
                if (node.nodeType === 1)
                    ko.virtualElements.normaliseVirtualElementDomStructure(node); return applyBindingsToNodeInternal(node, bindings, viewModel, true);
            }; ko.applyBindingsToDescendants = function (viewModel, rootNode) {
                if (rootNode.nodeType === 1 || rootNode.nodeType === 8)
                    applyBindingsToDescendantsInternal(viewModel, rootNode, true);
            }; ko.applyBindings = function (viewModel, rootNode) {
                if (rootNode && (rootNode.nodeType !== 1) && (rootNode.nodeType !== 8))
                    throw new Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node"); rootNode = rootNode || window.document.body; applyBindingsToNodeAndDescendantsInternal(viewModel, rootNode, true);
            }; ko.contextFor = function (node) {
                switch (node.nodeType) { case 1: case 8: var context = ko.storedBindingContextForNode(node); if (context) return context; if (node.parentNode) return ko.contextFor(node.parentNode); break; }
                return undefined;
            }; ko.dataFor = function (node) { var context = ko.contextFor(node); return context ? context['$data'] : undefined; }; ko.exportSymbol('bindingHandlers', ko.bindingHandlers); ko.exportSymbol('applyBindings', ko.applyBindings); ko.exportSymbol('applyBindingsToDescendants', ko.applyBindingsToDescendants); ko.exportSymbol('applyBindingsToNode', ko.applyBindingsToNode); ko.exportSymbol('contextFor', ko.contextFor); ko.exportSymbol('dataFor', ko.dataFor);
        })(); var eventHandlersWithShortcuts = ['click']; ko.utils.arrayForEach(eventHandlersWithShortcuts, function (eventName) { ko.bindingHandlers[eventName] = { 'init': function (element, valueAccessor, allBindingsAccessor, viewModel) { var newValueAccessor = function () { var result = {}; result[eventName] = valueAccessor(); return result; }; return ko.bindingHandlers['event']['init'].call(this, element, newValueAccessor, allBindingsAccessor, viewModel); } } }); ko.bindingHandlers['event'] = {
            'init': function (element, valueAccessor, allBindingsAccessor, viewModel) {
                var eventsToHandle = valueAccessor() || {}; for (var eventNameOutsideClosure in eventsToHandle) {
                    (function () {
                        var eventName = eventNameOutsideClosure; if (typeof eventName == "string") {
                            ko.utils.registerEventHandler(element, eventName, function (event) {
                                var handlerReturnValue; var handlerFunction = valueAccessor()[eventName]; if (!handlerFunction)
                                    return; var allBindings = allBindingsAccessor(); try { var argsForHandler = ko.utils.makeArray(arguments); argsForHandler.unshift(viewModel); handlerReturnValue = handlerFunction.apply(viewModel, argsForHandler); } finally {
                                        if (handlerReturnValue !== true) {
                                            if (event.preventDefault)
                                                event.preventDefault(); else
                                                event.returnValue = false;
                                        }
                                    }
                                var bubble = allBindings[eventName + 'Bubble'] !== false; if (!bubble) {
                                    event.cancelBubble = true; if (event.stopPropagation)
                                        event.stopPropagation();
                                }
                            });
                        }
                    })();
                }
            }
        }; ko.bindingHandlers['submit'] = {
            'init': function (element, valueAccessor, allBindingsAccessor, viewModel) {
                if (typeof valueAccessor() != "function")
                    throw new Error("The value for a submit binding must be a function"); ko.utils.registerEventHandler(element, "submit", function (event) {
                        var handlerReturnValue; var value = valueAccessor(); try { handlerReturnValue = value.call(viewModel, element); }
                        finally {
                            if (handlerReturnValue !== true) {
                                if (event.preventDefault)
                                    event.preventDefault(); else
                                    event.returnValue = false;
                            }
                        }
                    });
            }
        }; ko.bindingHandlers['visible'] = {
            'update': function (element, valueAccessor) {
                var value = ko.utils.unwrapObservable(valueAccessor()); var isCurrentlyVisible = !(element.style.display == "none"); if (value && !isCurrentlyVisible)
                    element.style.display = ""; else if ((!value) && isCurrentlyVisible)
                        element.style.display = "none";
            }
        }
        ko.bindingHandlers['enable'] = {
            'update': function (element, valueAccessor) {
                var value = ko.utils.unwrapObservable(valueAccessor()); if (value && element.disabled)
                    element.removeAttribute("disabled"); else if ((!value) && (!element.disabled))
                        element.disabled = true;
            }
        }; ko.bindingHandlers['disable'] = { 'update': function (element, valueAccessor) { ko.bindingHandlers['enable']['update'](element, function () { return !ko.utils.unwrapObservable(valueAccessor()) }); } }; function ensureDropdownSelectionIsConsistentWithModelValue(element, modelValue, preferModelValue) {
            if (preferModelValue) {
                if (modelValue !== ko.selectExtensions.readValue(element))
                    ko.selectExtensions.writeValue(element, modelValue);
            }
            if (modelValue !== ko.selectExtensions.readValue(element))
                ko.utils.triggerEvent(element, "change");
        }; ko.bindingHandlers['value'] = {
            'init': function (element, valueAccessor, allBindingsAccessor) {
                var eventsToCatch = ["change"]; var requestedEventsToCatch = allBindingsAccessor()["valueUpdate"]; if (requestedEventsToCatch) {
                    if (typeof requestedEventsToCatch == "string")
                        requestedEventsToCatch = [requestedEventsToCatch]; ko.utils.arrayPushAll(eventsToCatch, requestedEventsToCatch); eventsToCatch = ko.utils.arrayGetDistinctValues(eventsToCatch);
                }
                var valueUpdateHandler = function () { var modelValue = valueAccessor(); var elementValue = ko.selectExtensions.readValue(element); ko.jsonExpressionRewriting.writeValueToProperty(modelValue, allBindingsAccessor, 'value', elementValue, true); }
                var ieAutoCompleteHackNeeded = ko.utils.ieVersion && element.tagName.toLowerCase() == "input" && element.type == "text" && element.autocomplete != "off" && (!element.form || element.form.autocomplete != "off"); if (ieAutoCompleteHackNeeded && ko.utils.arrayIndexOf(eventsToCatch, "propertychange") == -1) { var propertyChangedFired = false; ko.utils.registerEventHandler(element, "propertychange", function () { propertyChangedFired = true }); ko.utils.registerEventHandler(element, "blur", function () { if (propertyChangedFired) { propertyChangedFired = false; valueUpdateHandler(); } }); }
                ko.utils.arrayForEach(eventsToCatch, function (eventName) {
                    var handler = valueUpdateHandler; if (ko.utils.stringStartsWith(eventName, "after")) { handler = function () { setTimeout(valueUpdateHandler, 0) }; eventName = eventName.substring("after".length); }
                    ko.utils.registerEventHandler(element, eventName, handler);
                });
            }, 'update': function (element, valueAccessor) {
                var valueIsSelectOption = ko.utils.tagNameLower(element) === "select"; var newValue = ko.utils.unwrapObservable(valueAccessor()); var elementValue = ko.selectExtensions.readValue(element); var valueHasChanged = (newValue != elementValue); if ((newValue === 0) && (elementValue !== 0) && (elementValue !== "0"))
                    valueHasChanged = true; if (valueHasChanged) {
                        var applyValueAction = function () { ko.selectExtensions.writeValue(element, newValue); }; applyValueAction(); var alsoApplyAsynchronously = valueIsSelectOption; if (alsoApplyAsynchronously)
                            setTimeout(applyValueAction, 0);
                    }
                if (valueIsSelectOption && (element.length > 0))
                    ensureDropdownSelectionIsConsistentWithModelValue(element, newValue, false);
            }
        }; ko.bindingHandlers['options'] = {
            'update': function (element, valueAccessor, allBindingsAccessor) {
                if (ko.utils.tagNameLower(element) !== "select")
                    throw new Error("options binding applies only to SELECT elements"); var selectWasPreviouslyEmpty = element.length == 0; var previousSelectedValues = ko.utils.arrayMap(ko.utils.arrayFilter(element.childNodes, function (node) { return node.tagName && (ko.utils.tagNameLower(node) === "option") && node.selected; }), function (node) { return ko.selectExtensions.readValue(node) || node.innerText || node.textContent; }); var previousScrollTop = element.scrollTop; var value = ko.utils.unwrapObservable(valueAccessor()); var selectedValue = element.value; while (element.length > 0) { ko.cleanNode(element.options[0]); element.remove(0); }
                if (value) {
                    var allBindings = allBindingsAccessor(); if (typeof value.length != "number")
                        value = [value]; if (allBindings['optionsCaption']) { var option = document.createElement("option"); ko.utils.setHtml(option, allBindings['optionsCaption']); ko.selectExtensions.writeValue(option, undefined); element.appendChild(option); }
                    for (var i = 0, j = value.length; i < j; i++) {
                        var option = document.createElement("option"); var optionValue = typeof allBindings['optionsValue'] == "string" ? value[i][allBindings['optionsValue']] : value[i]; optionValue = ko.utils.unwrapObservable(optionValue); ko.selectExtensions.writeValue(option, optionValue); var optionsTextValue = allBindings['optionsText']; var optionText; if (typeof optionsTextValue == "function")
                            optionText = optionsTextValue(value[i]); else if (typeof optionsTextValue == "string")
                                optionText = value[i][optionsTextValue]; else
                                optionText = optionValue; if ((optionText === null) || (optionText === undefined))
                                    optionText = ""; ko.utils.setTextContent(option, optionText); element.appendChild(option);
                    }
                    var newOptions = element.getElementsByTagName("option"); var countSelectionsRetained = 0; for (var i = 0, j = newOptions.length; i < j; i++) { if (ko.utils.arrayIndexOf(previousSelectedValues, ko.selectExtensions.readValue(newOptions[i])) >= 0) { ko.utils.setOptionNodeSelectionState(newOptions[i], true); countSelectionsRetained++; } }
                    element.scrollTop = previousScrollTop; if (selectWasPreviouslyEmpty && ('value' in allBindings)) { ensureDropdownSelectionIsConsistentWithModelValue(element, ko.utils.unwrapObservable(allBindings['value']), true); }
                    ko.utils.ensureSelectElementIsRenderedCorrectly(element);
                }
            }
        }; ko.bindingHandlers['options'].optionValueDomDataKey = '__ko.optionValueDomData__'; ko.bindingHandlers['selectedOptions'] = {
            getSelectedValuesFromSelectNode: function (selectNode) {
                var result = []; var nodes = selectNode.childNodes; for (var i = 0, j = nodes.length; i < j; i++) {
                    var node = nodes[i], tagName = ko.utils.tagNameLower(node); if (tagName == "option" && node.selected)
                        result.push(ko.selectExtensions.readValue(node)); else if (tagName == "optgroup") { var selectedValuesFromOptGroup = ko.bindingHandlers['selectedOptions'].getSelectedValuesFromSelectNode(node); Array.prototype.splice.apply(result, [result.length, 0].concat(selectedValuesFromOptGroup)); }
                }
                return result;
            }, 'init': function (element, valueAccessor, allBindingsAccessor) { ko.utils.registerEventHandler(element, "change", function () { var value = valueAccessor(); var valueToWrite = ko.bindingHandlers['selectedOptions'].getSelectedValuesFromSelectNode(this); ko.jsonExpressionRewriting.writeValueToProperty(value, allBindingsAccessor, 'value', valueToWrite); }); }, 'update': function (element, valueAccessor) {
                if (ko.utils.tagNameLower(element) != "select")
                    throw new Error("values binding applies only to SELECT elements"); var newValue = ko.utils.unwrapObservable(valueAccessor()); if (newValue && typeof newValue.length == "number") {
                        var nodes = element.childNodes; for (var i = 0, j = nodes.length; i < j; i++) {
                            var node = nodes[i]; if (ko.utils.tagNameLower(node) === "option")
                                ko.utils.setOptionNodeSelectionState(node, ko.utils.arrayIndexOf(newValue, ko.selectExtensions.readValue(node)) >= 0);
                        }
                    }
            }
        }; ko.bindingHandlers['text'] = { 'update': function (element, valueAccessor) { ko.utils.setTextContent(element, valueAccessor()); } }; ko.bindingHandlers['html'] = { 'init': function () { return { 'controlsDescendantBindings': true }; }, 'update': function (element, valueAccessor) { var value = ko.utils.unwrapObservable(valueAccessor()); ko.utils.setHtml(element, value); } }; ko.bindingHandlers['css'] = { 'update': function (element, valueAccessor) { var value = ko.utils.unwrapObservable(valueAccessor() || {}); for (var className in value) { if (typeof className == "string") { var shouldHaveClass = ko.utils.unwrapObservable(value[className]); ko.utils.toggleDomNodeCssClass(element, className, shouldHaveClass); } } } }; ko.bindingHandlers['style'] = { 'update': function (element, valueAccessor) { var value = ko.utils.unwrapObservable(valueAccessor() || {}); for (var styleName in value) { if (typeof styleName == "string") { var styleValue = ko.utils.unwrapObservable(value[styleName]); element.style[styleName] = styleValue || ""; } } } }; ko.bindingHandlers['uniqueName'] = {
            'init': function (element, valueAccessor) {
                if (valueAccessor()) {
                    element.name = "ko_unique_" + (++ko.bindingHandlers['uniqueName'].currentIndex); if (ko.utils.isIe6 || ko.utils.isIe7)
                        element.mergeAttributes(document.createElement("<input name='" + element.name + "'/>"), false);
                }
            }
        }; ko.bindingHandlers['uniqueName'].currentIndex = 0; ko.bindingHandlers['checked'] = {
            'init': function (element, valueAccessor, allBindingsAccessor) {
                var updateHandler = function () {
                    var valueToWrite; if (element.type == "checkbox") { valueToWrite = element.checked; } else if ((element.type == "radio") && (element.checked)) { valueToWrite = element.value; } else { return; }
                    var modelValue = valueAccessor(); if ((element.type == "checkbox") && (ko.utils.unwrapObservable(modelValue) instanceof Array)) {
                        var existingEntryIndex = ko.utils.arrayIndexOf(ko.utils.unwrapObservable(modelValue), element.value); if (element.checked && (existingEntryIndex < 0))
                            modelValue.push(element.value); else if ((!element.checked) && (existingEntryIndex >= 0))
                                modelValue.splice(existingEntryIndex, 1);
                    } else { ko.jsonExpressionRewriting.writeValueToProperty(modelValue, allBindingsAccessor, 'checked', valueToWrite, true); }
                }; ko.utils.registerEventHandler(element, "click", updateHandler); if ((element.type == "radio") && !element.name)
                    ko.bindingHandlers['uniqueName']['init'](element, function () { return true });
            }, 'update': function (element, valueAccessor) { var value = ko.utils.unwrapObservable(valueAccessor()); if (element.type == "checkbox") { if (value instanceof Array) { element.checked = ko.utils.arrayIndexOf(value, element.value) >= 0; } else { element.checked = value; } } else if (element.type == "radio") { element.checked = (element.value == value); } }
        }; var attrHtmlToJavascriptMap = { 'class': 'className', 'for': 'htmlFor' }; ko.bindingHandlers['attr'] = {
            'update': function (element, valueAccessor, allBindingsAccessor) {
                var value = ko.utils.unwrapObservable(valueAccessor()) || {}; for (var attrName in value) {
                    if (typeof attrName == "string") {
                        var attrValue = ko.utils.unwrapObservable(value[attrName]); var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined); if (toRemove)
                            element.removeAttribute(attrName); if (ko.utils.ieVersion <= 8 && attrName in attrHtmlToJavascriptMap) {
                                attrName = attrHtmlToJavascriptMap[attrName]; if (toRemove)
                                    element.removeAttribute(attrName); else
                                    element[attrName] = attrValue;
                            } else if (!toRemove) { element.setAttribute(attrName, attrValue.toString()); }
                    }
                }
            }
        }; ko.bindingHandlers['hasfocus'] = { 'init': function (element, valueAccessor, allBindingsAccessor) { var writeValue = function (valueToWrite) { var modelValue = valueAccessor(); ko.jsonExpressionRewriting.writeValueToProperty(modelValue, allBindingsAccessor, 'hasfocus', valueToWrite, true); }; ko.utils.registerEventHandler(element, "focus", function () { writeValue(true) }); ko.utils.registerEventHandler(element, "focusin", function () { writeValue(true) }); ko.utils.registerEventHandler(element, "blur", function () { writeValue(false) }); ko.utils.registerEventHandler(element, "focusout", function () { writeValue(false) }); }, 'update': function (element, valueAccessor) { var value = ko.utils.unwrapObservable(valueAccessor()); value ? element.focus() : element.blur(); ko.utils.triggerEvent(element, value ? "focusin" : "focusout"); } }; ko.bindingHandlers['with'] = { makeTemplateValueAccessor: function (valueAccessor) { return function () { var value = valueAccessor(); return { 'if': value, 'data': value, 'templateEngine': ko.nativeTemplateEngine.instance } }; }, 'init': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) { return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['with'].makeTemplateValueAccessor(valueAccessor)); }, 'update': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) { return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['with'].makeTemplateValueAccessor(valueAccessor), allBindingsAccessor, viewModel, bindingContext); } }; ko.jsonExpressionRewriting.bindingRewriteValidators['with'] = false; ko.virtualElements.allowedBindings['with'] = true; ko.bindingHandlers['if'] = { makeTemplateValueAccessor: function (valueAccessor) { return function () { return { 'if': valueAccessor(), 'templateEngine': ko.nativeTemplateEngine.instance } }; }, 'init': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) { return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['if'].makeTemplateValueAccessor(valueAccessor)); }, 'update': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) { return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['if'].makeTemplateValueAccessor(valueAccessor), allBindingsAccessor, viewModel, bindingContext); } }; ko.jsonExpressionRewriting.bindingRewriteValidators['if'] = false; ko.virtualElements.allowedBindings['if'] = true; ko.bindingHandlers['ifnot'] = { makeTemplateValueAccessor: function (valueAccessor) { return function () { return { 'ifnot': valueAccessor(), 'templateEngine': ko.nativeTemplateEngine.instance } }; }, 'init': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) { return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['ifnot'].makeTemplateValueAccessor(valueAccessor)); }, 'update': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) { return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['ifnot'].makeTemplateValueAccessor(valueAccessor), allBindingsAccessor, viewModel, bindingContext); } }; ko.jsonExpressionRewriting.bindingRewriteValidators['ifnot'] = false; ko.virtualElements.allowedBindings['ifnot'] = true; ko.bindingHandlers['foreach'] = {
            makeTemplateValueAccessor: function (valueAccessor) {
                return function () {
                    var bindingValue = ko.utils.unwrapObservable(valueAccessor()); if ((!bindingValue) || typeof bindingValue.length == "number")
                        return { 'foreach': bindingValue, 'templateEngine': ko.nativeTemplateEngine.instance }; return { 'foreach': bindingValue['data'], 'includeDestroyed': bindingValue['includeDestroyed'], 'afterAdd': bindingValue['afterAdd'], 'beforeRemove': bindingValue['beforeRemove'], 'afterRender': bindingValue['afterRender'], 'templateEngine': ko.nativeTemplateEngine.instance };
                };
            }, 'init': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) { return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor)); }, 'update': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) { return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor), allBindingsAccessor, viewModel, bindingContext); }
        }; ko.jsonExpressionRewriting.bindingRewriteValidators['foreach'] = false; ko.virtualElements.allowedBindings['foreach'] = true; ko.templateEngine = function () { }; ko.templateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options) { throw new Error("Override renderTemplateSource"); }; ko.templateEngine.prototype['createJavaScriptEvaluatorBlock'] = function (script) { throw new Error("Override createJavaScriptEvaluatorBlock"); }; ko.templateEngine.prototype['makeTemplateSource'] = function (template, templateDocument) {
            if (typeof template == "string") {
                templateDocument = templateDocument || document; var elem = templateDocument.getElementById(template); if (!elem)
                    throw new Error("Cannot find template with ID " + template); return new ko.templateSources.domElement(elem);
            } else if ((template.nodeType == 1) || (template.nodeType == 8)) { return new ko.templateSources.anonymousTemplate(template); } else
                throw new Error("Unknown template type: " + template);
        }; ko.templateEngine.prototype['renderTemplate'] = function (template, bindingContext, options, templateDocument) { var templateSource = this['makeTemplateSource'](template, templateDocument); return this['renderTemplateSource'](templateSource, bindingContext, options); }; ko.templateEngine.prototype['isTemplateRewritten'] = function (template, templateDocument) {
            if (this['allowTemplateRewriting'] === false)
                return true; var templateIsInExternalDocument = templateDocument && templateDocument != document; if (!templateIsInExternalDocument && this.knownRewrittenTemplates && this.knownRewrittenTemplates[template])
                    return true; return this['makeTemplateSource'](template, templateDocument)['data']("isRewritten");
        }; ko.templateEngine.prototype['rewriteTemplate'] = function (template, rewriterCallback, templateDocument) { var templateSource = this['makeTemplateSource'](template, templateDocument); var rewritten = rewriterCallback(templateSource['text']()); templateSource['text'](rewritten); templateSource['data']("isRewritten", true); var templateIsInExternalDocument = templateDocument && templateDocument != document; if (!templateIsInExternalDocument && typeof template == "string") { this.knownRewrittenTemplates = this.knownRewrittenTemplates || {}; this.knownRewrittenTemplates[template] = true; } }; ko.exportSymbol('templateEngine', ko.templateEngine); ko.templateRewriting = (function () {
            var memoizeDataBindingAttributeSyntaxRegex = /(<[a-z]+\d*(\s+(?!data-bind=)[a-z0-9\-]+(=(\"[^\"]*\"|\'[^\']*\'))?)*\s+)data-bind=(["'])([\s\S]*?)\5/gi; var memoizeVirtualContainerBindingSyntaxRegex = /<!--\s*ko\b\s*([\s\S]*?)\s*-->/g; function validateDataBindValuesForRewriting(keyValueArray) {
                var allValidators = ko.jsonExpressionRewriting.bindingRewriteValidators; for (var i = 0; i < keyValueArray.length; i++) {
                    var key = keyValueArray[i]['key']; if (allValidators.hasOwnProperty(key)) {
                        var validator = allValidators[key]; if (typeof validator === "function") {
                            var possibleErrorMessage = validator(keyValueArray[i]['value']); if (possibleErrorMessage)
                                throw new Error(possibleErrorMessage);
                        } else if (!validator) { throw new Error("This template engine does not support the '" + key + "' binding within its templates"); }
                    }
                }
            }
            function constructMemoizedTagReplacement(dataBindAttributeValue, tagToRetain, templateEngine) {
                var dataBindKeyValueArray = ko.jsonExpressionRewriting.parseObjectLiteral(dataBindAttributeValue); validateDataBindValuesForRewriting(dataBindKeyValueArray); var rewrittenDataBindAttributeValue = ko.jsonExpressionRewriting.insertPropertyAccessorsIntoJson(dataBindKeyValueArray); var applyBindingsToNextSiblingScript = "ko.templateRewriting.applyMemoizedBindingsToNextSibling(function() { \
            return (function() { return { "+ rewrittenDataBindAttributeValue + " } })() \
        })"; return templateEngine['createJavaScriptEvaluatorBlock'](applyBindingsToNextSiblingScript) + tagToRetain;
            }
            return {
                ensureTemplateIsRewritten: function (template, templateEngine, templateDocument) {
                    if (!templateEngine['isTemplateRewritten'](template, templateDocument))
                        templateEngine['rewriteTemplate'](template, function (htmlString) { return ko.templateRewriting.memoizeBindingAttributeSyntax(htmlString, templateEngine); }, templateDocument);
                }, memoizeBindingAttributeSyntax: function (htmlString, templateEngine) { return htmlString.replace(memoizeDataBindingAttributeSyntaxRegex, function () { return constructMemoizedTagReplacement(arguments[6], arguments[1], templateEngine); }).replace(memoizeVirtualContainerBindingSyntaxRegex, function () { return constructMemoizedTagReplacement(arguments[1], "<!-- ko -->", templateEngine); }); }, applyMemoizedBindingsToNextSibling: function (bindings) {
                    return ko.memoization.memoize(function (domNode, bindingContext) {
                        if (domNode.nextSibling)
                            ko.applyBindingsToNode(domNode.nextSibling, bindings, bindingContext);
                    });
                }
            }
        })(); ko.exportSymbol('templateRewriting', ko.templateRewriting); ko.exportSymbol('templateRewriting.applyMemoizedBindingsToNextSibling', ko.templateRewriting.applyMemoizedBindingsToNextSibling); (function () {
            ko.templateSources = {}; ko.templateSources.domElement = function (element) { this.domElement = element; }
            ko.templateSources.domElement.prototype['text'] = function () {
                var tagNameLower = ko.utils.tagNameLower(this.domElement), elemContentsProperty = tagNameLower === "script" ? "text" : tagNameLower === "textarea" ? "value" : "innerHTML"; if (arguments.length == 0) { return this.domElement[elemContentsProperty]; } else {
                    var valueToWrite = arguments[0]; if (elemContentsProperty === "innerHTML")
                        ko.utils.setHtml(this.domElement, valueToWrite); else
                        this.domElement[elemContentsProperty] = valueToWrite;
                }
            }; ko.templateSources.domElement.prototype['data'] = function (key) { if (arguments.length === 1) { return ko.utils.domData.get(this.domElement, "templateSourceData_" + key); } else { ko.utils.domData.set(this.domElement, "templateSourceData_" + key, arguments[1]); } }; var anonymousTemplatesDomDataKey = "__ko_anon_template__"; ko.templateSources.anonymousTemplate = function (element) { this.domElement = element; }
            ko.templateSources.anonymousTemplate.prototype = new ko.templateSources.domElement(); ko.templateSources.anonymousTemplate.prototype['text'] = function () {
                if (arguments.length == 0) {
                    var templateData = ko.utils.domData.get(this.domElement, anonymousTemplatesDomDataKey) || {}; if (templateData.textData === undefined && templateData.containerData)
                        templateData.textData = templateData.containerData.innerHTML; return templateData.textData;
                } else { var valueToWrite = arguments[0]; ko.utils.domData.set(this.domElement, anonymousTemplatesDomDataKey, { textData: valueToWrite }); }
            }; ko.templateSources.domElement.prototype['nodes'] = function () { if (arguments.length == 0) { var templateData = ko.utils.domData.get(this.domElement, anonymousTemplatesDomDataKey) || {}; return templateData.containerData; } else { var valueToWrite = arguments[0]; ko.utils.domData.set(this.domElement, anonymousTemplatesDomDataKey, { containerData: valueToWrite }); } }; ko.exportSymbol('templateSources', ko.templateSources); ko.exportSymbol('templateSources.domElement', ko.templateSources.domElement); ko.exportSymbol('templateSources.anonymousTemplate', ko.templateSources.anonymousTemplate);
        })(); (function () {
            var _templateEngine; ko.setTemplateEngine = function (templateEngine) {
                if ((templateEngine != undefined) && !(templateEngine instanceof ko.templateEngine))
                    throw new Error("templateEngine must inherit from ko.templateEngine"); _templateEngine = templateEngine;
            }
            function invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, action) {
                var node, nextInQueue = firstNode, firstOutOfRangeNode = ko.virtualElements.nextSibling(lastNode); while (nextInQueue && ((node = nextInQueue) !== firstOutOfRangeNode)) {
                    nextInQueue = ko.virtualElements.nextSibling(node); if (node.nodeType === 1 || node.nodeType === 8)
                        action(node);
                }
            }
            function activateBindingsOnContinuousNodeArray(continuousNodeArray, bindingContext) { if (continuousNodeArray.length) { var firstNode = continuousNodeArray[0], lastNode = continuousNodeArray[continuousNodeArray.length - 1]; invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, function (node) { ko.applyBindings(bindingContext, node); }); invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, function (node) { ko.memoization.unmemoizeDomNodeAndDescendants(node, [bindingContext]); }); } }
            function getFirstNodeFromPossibleArray(nodeOrNodeArray) { return nodeOrNodeArray.nodeType ? nodeOrNodeArray : nodeOrNodeArray.length > 0 ? nodeOrNodeArray[0] : null; }
            function executeTemplate(targetNodeOrNodeArray, renderMode, template, bindingContext, options) {
                options = options || {}; var firstTargetNode = targetNodeOrNodeArray && getFirstNodeFromPossibleArray(targetNodeOrNodeArray); var templateDocument = firstTargetNode && firstTargetNode.ownerDocument; var templateEngineToUse = (options['templateEngine'] || _templateEngine); ko.templateRewriting.ensureTemplateIsRewritten(template, templateEngineToUse, templateDocument); var renderedNodesArray = templateEngineToUse['renderTemplate'](template, bindingContext, options, templateDocument); if ((typeof renderedNodesArray.length != "number") || (renderedNodesArray.length > 0 && typeof renderedNodesArray[0].nodeType != "number"))
                    throw new Error("Template engine must return an array of DOM nodes"); var haveAddedNodesToParent = false; switch (renderMode) { case "replaceChildren": ko.virtualElements.setDomNodeChildren(targetNodeOrNodeArray, renderedNodesArray); haveAddedNodesToParent = true; break; case "replaceNode": ko.utils.replaceDomNodes(targetNodeOrNodeArray, renderedNodesArray); haveAddedNodesToParent = true; break; case "ignoreTargetNode": break; default: throw new Error("Unknown renderMode: " + renderMode); }
                if (haveAddedNodesToParent) {
                    activateBindingsOnContinuousNodeArray(renderedNodesArray, bindingContext); if (options['afterRender'])
                        options['afterRender'](renderedNodesArray, bindingContext['$data']);
                }
                return renderedNodesArray;
            }
            ko.renderTemplate = function (template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode) {
                options = options || {}; if ((options['templateEngine'] || _templateEngine) == undefined)
                    throw new Error("Set a template engine before calling renderTemplate"); renderMode = renderMode || "replaceChildren"; if (targetNodeOrNodeArray) { var firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray); var whenToDispose = function () { return (!firstTargetNode) || !ko.utils.domNodeIsAttachedToDocument(firstTargetNode); }; var activelyDisposeWhenNodeIsRemoved = (firstTargetNode && renderMode == "replaceNode") ? firstTargetNode.parentNode : firstTargetNode; return ko.dependentObservable(function () { var bindingContext = (dataOrBindingContext && (dataOrBindingContext instanceof ko.bindingContext)) ? dataOrBindingContext : new ko.bindingContext(ko.utils.unwrapObservable(dataOrBindingContext)); var templateName = typeof (template) == 'function' ? template(bindingContext['$data']) : template; var renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options); if (renderMode == "replaceNode") { targetNodeOrNodeArray = renderedNodesArray; firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray); } }, null, { 'disposeWhen': whenToDispose, 'disposeWhenNodeIsRemoved': activelyDisposeWhenNodeIsRemoved }); } else { return ko.memoization.memoize(function (domNode) { ko.renderTemplate(template, dataOrBindingContext, options, domNode, "replaceNode"); }); }
            }; ko.renderTemplateForEach = function (template, arrayOrObservableArray, options, targetNode, parentBindingContext) {
                var arrayItemContext; var executeTemplateForArrayItem = function (arrayValue, index) { var templateName = typeof (template) == 'function' ? template(arrayValue) : template; arrayItemContext = parentBindingContext['createChildContext'](ko.utils.unwrapObservable(arrayValue)); arrayItemContext['$index'] = index; return executeTemplate(null, "ignoreTargetNode", templateName, arrayItemContext, options); }
                var activateBindingsCallback = function (arrayValue, addedNodesArray, index) {
                    activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext); if (options['afterRender'])
                        options['afterRender'](addedNodesArray, arrayValue);
                }; return ko.dependentObservable(function () {
                    var unwrappedArray = ko.utils.unwrapObservable(arrayOrObservableArray) || []; if (typeof unwrappedArray.length == "undefined")
                        unwrappedArray = [unwrappedArray]; var filteredArray = ko.utils.arrayFilter(unwrappedArray, function (item) { return options['includeDestroyed'] || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']); }); ko.utils.setDomNodeChildrenFromArrayMapping(targetNode, filteredArray, executeTemplateForArrayItem, options, activateBindingsCallback);
                }, null, { 'disposeWhenNodeIsRemoved': targetNode });
            }; var templateSubscriptionDomDataKey = '__ko__templateSubscriptionDomDataKey__'; function disposeOldSubscriptionAndStoreNewOne(element, newSubscription) {
                var oldSubscription = ko.utils.domData.get(element, templateSubscriptionDomDataKey); if (oldSubscription && (typeof (oldSubscription.dispose) == 'function'))
                    oldSubscription.dispose(); ko.utils.domData.set(element, templateSubscriptionDomDataKey, newSubscription);
            }
            ko.bindingHandlers['template'] = {
                'init': function (element, valueAccessor) {
                    var bindingValue = ko.utils.unwrapObservable(valueAccessor()); if ((typeof bindingValue != "string") && (!bindingValue['name']) && (element.nodeType == 1 || element.nodeType == 8)) { var templateNodes = element.nodeType == 1 ? element.childNodes : ko.virtualElements.childNodes(element), container = ko.utils.moveCleanedNodesToContainerElement(templateNodes); new ko.templateSources.anonymousTemplate(element)['nodes'](container); }
                    return { 'controlsDescendantBindings': true };
                }, 'update': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                    var bindingValue = ko.utils.unwrapObservable(valueAccessor()); var templateName; var shouldDisplay = true; if (typeof bindingValue == "string") { templateName = bindingValue; } else {
                        templateName = bindingValue['name']; if ('if' in bindingValue)
                            shouldDisplay = shouldDisplay && ko.utils.unwrapObservable(bindingValue['if']); if ('ifnot' in bindingValue)
                                shouldDisplay = shouldDisplay && !ko.utils.unwrapObservable(bindingValue['ifnot']);
                    }
                    var templateSubscription = null; if ((typeof bindingValue === 'object') && ('foreach' in bindingValue)) { var dataArray = (shouldDisplay && bindingValue['foreach']) || []; templateSubscription = ko.renderTemplateForEach(templateName || element, dataArray, bindingValue, element, bindingContext); } else {
                        if (shouldDisplay) { var innerBindingContext = (typeof bindingValue == 'object') && ('data' in bindingValue) ? bindingContext['createChildContext'](ko.utils.unwrapObservable(bindingValue['data'])) : bindingContext; templateSubscription = ko.renderTemplate(templateName || element, innerBindingContext, bindingValue, element); } else
                            ko.virtualElements.emptyNode(element);
                    }
                    disposeOldSubscriptionAndStoreNewOne(element, templateSubscription);
                }
            }; ko.jsonExpressionRewriting.bindingRewriteValidators['template'] = function (bindingValue) {
                var parsedBindingValue = ko.jsonExpressionRewriting.parseObjectLiteral(bindingValue); if ((parsedBindingValue.length == 1) && parsedBindingValue[0]['unknown'])
                    return null; if (ko.jsonExpressionRewriting.keyValueArrayContainsKey(parsedBindingValue, "name"))
                        return null; return "This template engine does not support anonymous templates nested within its templates";
            }; ko.virtualElements.allowedBindings['template'] = true;
        })(); ko.exportSymbol('setTemplateEngine', ko.setTemplateEngine); ko.exportSymbol('renderTemplate', ko.renderTemplate); (function () {
            function calculateEditDistanceMatrix(oldArray, newArray, maxAllowedDistance) {
                var distances = []; for (var i = 0; i <= newArray.length; i++)
                    distances[i] = []; for (var i = 0, j = Math.min(oldArray.length, maxAllowedDistance) ; i <= j; i++)
                        distances[0][i] = i; for (var i = 1, j = Math.min(newArray.length, maxAllowedDistance) ; i <= j; i++) { distances[i][0] = i; }
                var oldIndex, oldIndexMax = oldArray.length, newIndex, newIndexMax = newArray.length; var distanceViaAddition, distanceViaDeletion; for (oldIndex = 1; oldIndex <= oldIndexMax; oldIndex++) {
                    var newIndexMinForRow = Math.max(1, oldIndex - maxAllowedDistance); var newIndexMaxForRow = Math.min(newIndexMax, oldIndex + maxAllowedDistance); for (newIndex = newIndexMinForRow; newIndex <= newIndexMaxForRow; newIndex++) {
                        if (oldArray[oldIndex - 1] === newArray[newIndex - 1])
                            distances[newIndex][oldIndex] = distances[newIndex - 1][oldIndex - 1]; else { var northDistance = distances[newIndex - 1][oldIndex] === undefined ? Number.MAX_VALUE : distances[newIndex - 1][oldIndex] + 1; var westDistance = distances[newIndex][oldIndex - 1] === undefined ? Number.MAX_VALUE : distances[newIndex][oldIndex - 1] + 1; distances[newIndex][oldIndex] = Math.min(northDistance, westDistance); }
                    }
                }
                return distances;
            }
            function findEditScriptFromEditDistanceMatrix(editDistanceMatrix, oldArray, newArray) {
                var oldIndex = oldArray.length; var newIndex = newArray.length; var editScript = []; var maxDistance = editDistanceMatrix[newIndex][oldIndex]; if (maxDistance === undefined)
                    return null; while ((oldIndex > 0) || (newIndex > 0)) { var me = editDistanceMatrix[newIndex][oldIndex]; var distanceViaAdd = (newIndex > 0) ? editDistanceMatrix[newIndex - 1][oldIndex] : maxDistance + 1; var distanceViaDelete = (oldIndex > 0) ? editDistanceMatrix[newIndex][oldIndex - 1] : maxDistance + 1; var distanceViaRetain = (newIndex > 0) && (oldIndex > 0) ? editDistanceMatrix[newIndex - 1][oldIndex - 1] : maxDistance + 1; if ((distanceViaAdd === undefined) || (distanceViaAdd < me - 1)) distanceViaAdd = maxDistance + 1; if ((distanceViaDelete === undefined) || (distanceViaDelete < me - 1)) distanceViaDelete = maxDistance + 1; if (distanceViaRetain < me - 1) distanceViaRetain = maxDistance + 1; if ((distanceViaAdd <= distanceViaDelete) && (distanceViaAdd < distanceViaRetain)) { editScript.push({ status: "added", value: newArray[newIndex - 1] }); newIndex--; } else if ((distanceViaDelete < distanceViaAdd) && (distanceViaDelete < distanceViaRetain)) { editScript.push({ status: "deleted", value: oldArray[oldIndex - 1] }); oldIndex--; } else { editScript.push({ status: "retained", value: oldArray[oldIndex - 1] }); newIndex--; oldIndex--; } }
                return editScript.reverse();
            }
            ko.utils.compareArrays = function (oldArray, newArray, maxEditsToConsider) { if (maxEditsToConsider === undefined) { return ko.utils.compareArrays(oldArray, newArray, 1) || ko.utils.compareArrays(oldArray, newArray, 10) || ko.utils.compareArrays(oldArray, newArray, Number.MAX_VALUE); } else { oldArray = oldArray || []; newArray = newArray || []; var editDistanceMatrix = calculateEditDistanceMatrix(oldArray, newArray, maxEditsToConsider); return findEditScriptFromEditDistanceMatrix(editDistanceMatrix, oldArray, newArray); } };
        })(); ko.exportSymbol('utils.compareArrays', ko.utils.compareArrays); (function () {
            function fixUpVirtualElements(contiguousNodeArray) {
                if (contiguousNodeArray.length > 2) {
                    var current = contiguousNodeArray[0], last = contiguousNodeArray[contiguousNodeArray.length - 1], newContiguousSet = [current]; while (current !== last) {
                        current = current.nextSibling; if (!current)
                            return; newContiguousSet.push(current);
                    }
                    Array.prototype.splice.apply(contiguousNodeArray, [0, contiguousNodeArray.length].concat(newContiguousSet));
                }
            }
            function mapNodeAndRefreshWhenChanged(containerNode, mapping, valueToMap, callbackAfterAddingNodes, index) {
                var mappedNodes = []; var dependentObservable = ko.dependentObservable(function () {
                    var newMappedNodes = mapping(valueToMap, index) || []; if (mappedNodes.length > 0) {
                        fixUpVirtualElements(mappedNodes); ko.utils.replaceDomNodes(mappedNodes, newMappedNodes); if (callbackAfterAddingNodes)
                            callbackAfterAddingNodes(valueToMap, newMappedNodes);
                    }
                    mappedNodes.splice(0, mappedNodes.length); ko.utils.arrayPushAll(mappedNodes, newMappedNodes);
                }, null, { 'disposeWhenNodeIsRemoved': containerNode, 'disposeWhen': function () { return (mappedNodes.length == 0) || !ko.utils.domNodeIsAttachedToDocument(mappedNodes[0]) } }); return { mappedNodes: mappedNodes, dependentObservable: dependentObservable };
            }
            var lastMappingResultDomDataKey = "setDomNodeChildrenFromArrayMapping_lastMappingResult"; ko.utils.setDomNodeChildrenFromArrayMapping = function (domNode, array, mapping, options, callbackAfterAddingNodes) {
                array = array || []; options = options || {}; var isFirstExecution = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) === undefined; var lastMappingResult = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) || []; var lastArray = ko.utils.arrayMap(lastMappingResult, function (x) { return x.arrayEntry; }); var editScript = ko.utils.compareArrays(lastArray, array); var newMappingResult = []; var lastMappingResultIndex = 0; var nodesToDelete = []; var newMappingResultIndex = 0; var nodesAdded = []; var insertAfterNode = null; for (var i = 0, j = editScript.length; i < j; i++) {
                    switch (editScript[i].status) {
                        case "retained": var dataToRetain = lastMappingResult[lastMappingResultIndex]; dataToRetain.indexObservable(newMappingResultIndex); newMappingResultIndex = newMappingResult.push(dataToRetain); if (dataToRetain.domNodes.length > 0)
                            insertAfterNode = dataToRetain.domNodes[dataToRetain.domNodes.length - 1]; lastMappingResultIndex++; break; case "deleted": lastMappingResult[lastMappingResultIndex].dependentObservable.dispose(); fixUpVirtualElements(lastMappingResult[lastMappingResultIndex].domNodes); ko.utils.arrayForEach(lastMappingResult[lastMappingResultIndex].domNodes, function (node) { nodesToDelete.push({ element: node, index: i, value: editScript[i].value }); insertAfterNode = node; }); lastMappingResultIndex++; break; case "added": var valueToMap = editScript[i].value; var indexObservable = ko.observable(newMappingResultIndex); var mapData = mapNodeAndRefreshWhenChanged(domNode, mapping, valueToMap, callbackAfterAddingNodes, indexObservable); var mappedNodes = mapData.mappedNodes; newMappingResultIndex = newMappingResult.push({ arrayEntry: editScript[i].value, domNodes: mappedNodes, dependentObservable: mapData.dependentObservable, indexObservable: indexObservable }); for (var nodeIndex = 0, nodeIndexMax = mappedNodes.length; nodeIndex < nodeIndexMax; nodeIndex++) {
                                var node = mappedNodes[nodeIndex]; nodesAdded.push({ element: node, index: i, value: editScript[i].value }); if (insertAfterNode == null) { ko.virtualElements.prepend(domNode, node); } else { ko.virtualElements.insertAfter(domNode, node, insertAfterNode); }
                                insertAfterNode = node;
                            }
                                if (callbackAfterAddingNodes)
                                    callbackAfterAddingNodes(valueToMap, mappedNodes, indexObservable); break;
                    }
                }
                ko.utils.arrayForEach(nodesToDelete, function (node) { ko.cleanNode(node.element) }); var invokedBeforeRemoveCallback = false; if (!isFirstExecution) {
                    if (options['afterAdd']) {
                        for (var i = 0; i < nodesAdded.length; i++)
                            options['afterAdd'](nodesAdded[i].element, nodesAdded[i].index, nodesAdded[i].value);
                    }
                    if (options['beforeRemove']) {
                        for (var i = 0; i < nodesToDelete.length; i++)
                            options['beforeRemove'](nodesToDelete[i].element, nodesToDelete[i].index, nodesToDelete[i].value); invokedBeforeRemoveCallback = true;
                    }
                }
                if (!invokedBeforeRemoveCallback && nodesToDelete.length) {
                    for (var i = 0; i < nodesToDelete.length; i++) {
                        var element = nodesToDelete[i].element; if (element.parentNode)
                            element.parentNode.removeChild(element);
                    }
                }
                ko.utils.domData.set(domNode, lastMappingResultDomDataKey, newMappingResult);
            }
        })(); ko.exportSymbol('utils.setDomNodeChildrenFromArrayMapping', ko.utils.setDomNodeChildrenFromArrayMapping); ko.nativeTemplateEngine = function () { this['allowTemplateRewriting'] = false; }
        ko.nativeTemplateEngine.prototype = new ko.templateEngine(); ko.nativeTemplateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options) { var useNodesIfAvailable = !(ko.utils.ieVersion < 9), templateNodesFunc = useNodesIfAvailable ? templateSource['nodes'] : null, templateNodes = templateNodesFunc ? templateSource['nodes']() : null; if (templateNodes) { return ko.utils.makeArray(templateNodes.cloneNode(true).childNodes); } else { var templateText = templateSource['text'](); return ko.utils.parseHtmlFragment(templateText); } }; ko.nativeTemplateEngine.instance = new ko.nativeTemplateEngine(); ko.setTemplateEngine(ko.nativeTemplateEngine.instance); ko.exportSymbol('nativeTemplateEngine', ko.nativeTemplateEngine); (function () {
            ko.jqueryTmplTemplateEngine = function () {
                var jQueryTmplVersion = this.jQueryTmplVersion = (function () {
                    if ((typeof (jQuery) == "undefined") || !(jQuery['tmpl']))
                        return 0; try { if (jQuery['tmpl']['tag']['tmpl']['open'].toString().indexOf('__') >= 0) { return 2; } } catch (ex) { }
                    return 1;
                })(); function ensureHasReferencedJQueryTemplates() {
                    if (jQueryTmplVersion < 2)
                        throw new Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");
                }
                function executeTemplate(compiledTemplate, data, jQueryTemplateOptions) { return jQuery['tmpl'](compiledTemplate, data, jQueryTemplateOptions); }
                this['renderTemplateSource'] = function (templateSource, bindingContext, options) {
                    options = options || {}; ensureHasReferencedJQueryTemplates(); var precompiled = templateSource['data']('precompiled'); if (!precompiled) { var templateText = templateSource['text']() || ""; templateText = "{{ko_with $item.koBindingContext}}" + templateText + "{{/ko_with}}"; precompiled = jQuery['template'](null, templateText); templateSource['data']('precompiled', precompiled); }
                    var data = [bindingContext['$data']]; var jQueryTemplateOptions = jQuery['extend']({ 'koBindingContext': bindingContext }, options['templateOptions']); var resultNodes = executeTemplate(precompiled, data, jQueryTemplateOptions); resultNodes['appendTo'](document.createElement("div")); jQuery['fragments'] = {}; return resultNodes;
                }; this['createJavaScriptEvaluatorBlock'] = function (script) { return "{{ko_code ((function() { return " + script + " })()) }}"; }; this['addTemplate'] = function (templateName, templateMarkup) { document.write("<script type='text/html' id='" + templateName + "'>" + templateMarkup + "</script>"); }; if (jQueryTmplVersion > 0) { jQuery['tmpl']['tag']['ko_code'] = { open: "__.push($1 || '');" }; jQuery['tmpl']['tag']['ko_with'] = { open: "with($1) {", close: "} " }; }
            }; ko.jqueryTmplTemplateEngine.prototype = new ko.templateEngine(); var jqueryTmplTemplateEngineInstance = new ko.jqueryTmplTemplateEngine(); if (jqueryTmplTemplateEngineInstance.jQueryTmplVersion > 0)
                ko.setTemplateEngine(jqueryTmplTemplateEngineInstance); ko.exportSymbol('jqueryTmplTemplateEngine', ko.jqueryTmplTemplateEngine);
        })();
    });
})(window, document, navigator);